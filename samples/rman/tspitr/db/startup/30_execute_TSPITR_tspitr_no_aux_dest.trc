
Recovery Manager: Release 19.0.0.0.0 - Production on Wed Feb 26 23:18:26 2020
Version 19.5.0.0.0

Copyright (c) 1982, 2019, Oracle and/or its affiliates.  All rights reserved.
ORACLE_HOME:    /u00/app/oracle/product/19.0.0.0
System name:	Linux
Node name:	tspitr
Release:	4.19.76-linuxkit
Version:	#1 SMP Thu Oct 17 19:31:58 UTC 2019
Machine:	x86_64

Starting with debugging set to level=9, types=ALL

DBGMISC:    krmiini: chkhangintrvl_krmsx set to 600  [23:18:26.844]

RMAN> 

DBGMISC:    Node # 1 [23:18:26.847]
DBGMISC:    TARGET = '********'
DBGMISC:    ENTERED krmice [23:18:26.848]
DBGMISC:     command to be compiled and executed is: TARGET  [23:18:26.848] (krmice)
DBGMISC:     command after this command is: NONE  [23:18:26.848] (krmice)
DBGMISC:     current incarnation does not matter for TARGET [23:18:26.849] (krmice)
DBGMISC:     ENTERED krmksimronly [23:18:26.975]

DBGSQL:       CHANNEL> alter session set events '19737 trace name context forever'
DBGSQL:          sqlcode = 0

DBGSQL:       CHANNEL> select decode(archiver, 'FAILED', 1, 0) into :archstuck from v$instance
DBGSQL:          sqlcode = 0
DBGSQL:           D :archstuck = 0

DBGSQL:       CHANNEL> alter session set events '19737 trace name context off'
DBGSQL:          sqlcode = 0
DBGMISC:     EXITED krmksimronly [23:18:26.989] elapsed time [00:00:00:00.014]

DBGSQL:      CHANNEL> select sys_context('userenv', 'con_id'), sys_context('userenv', 'cdb_name'), sys_context('userenv', 'con_name'), case when sys_context('userenv', 'is_application_root') = 'YES' then 1 else 0 end into :pdbid, :cdbname, :pdbname, :approot from dual
DBGSQL:         sqlcode = 0
DBGSQL:          D :pdbid = 1
DBGSQL:          D :cdbname = TRMAN01
DBGSQL:          D :pdbname = CDB$ROOT
DBGSQL:          D :approot = 0

DBGSQL:      CHANNEL> select decode(upper(value), 'TRUE', 1, 0)   into :parmvalue   from v$parameter  where lower(name) = '_pdb_name_case_sensitive'
DBGSQL:         sqlcode = 1403
DBGMISC:     ENTERED krmksimronly [23:18:27.113]
DBGMISC:     EXITED krmksimronly [23:18:27.113] elapsed time [00:00:00:00.000]

DBGSQL:      CHANNEL> select sys_context('userenv', 'con_id'), sys_context('userenv', 'cdb_name'), sys_context('userenv', 'con_name'), case when sys_context('userenv', 'is_application_root') = 'YES' then 1 else 0 end into :pdbid, :cdbname, :pdbname, :approot from dual
DBGSQL:         sqlcode = 0
DBGSQL:          D :pdbid = 1
DBGSQL:          D :cdbname = TRMAN01
DBGSQL:          D :pdbname = CDB$ROOT
DBGSQL:          D :approot = 0

DBGSQL:      CHANNEL> select decode(upper(value), 'TRUE', 1, 0)   into :parmvalue   from v$parameter  where lower(name) = '_pdb_name_case_sensitive'
DBGSQL:         sqlcode = 1403
DBGMISC:     ENTERED krmkgetdb [23:18:27.158]
DBGRPC:       krmxcc - entering
DBGRPC:       krmxcc - creating context for channel No-chid
DBGRPC:       krmxcc - connecting using target default channel
DBGRPC:       krmxcc - seting up for out-of-band
DBGRPC:       krmxpos - setting up channel No-chid
DBGRPC:       krmxpos - creating polling channel for channel No-chid
DBGMISC:      ENTERED krmksimronly [23:18:27.265]
DBGMISC:      EXITED krmksimronly [23:18:27.266] elapsed time [00:00:00:00.000]

DBGSQL:       CHANNEL> select sys_context('userenv', 'con_id'), sys_context('userenv', 'cdb_name'), sys_context('userenv', 'con_name'), case when sys_context('userenv', 'is_application_root') = 'YES' then 1 else 0 end into :pdbid, :cdbname, :pdbname, :approot from dual
DBGSQL:          sqlcode = 0
DBGSQL:           D :pdbid = 1
DBGSQL:           D :cdbname = TRMAN01
DBGSQL:           D :pdbname = CDB$ROOT
DBGSQL:           D :approot = 0

DBGSQL:       CHANNEL> select decode(upper(value), 'TRUE', 1, 0)   into :parmvalue   from v$parameter  where lower(name) = '_pdb_name_case_sensitive'
DBGSQL:          sqlcode = 1403
DBGRPC:       krmxpos - channel No-chid polling channel created to instance 1
DBGRPC:       krmxcc - using default sga_heap_size of 16777216
DBGRPC:       krmxcc - created context for channel No-chid
DBGMISC:      krmqopen: opening new channel context for channel default, instid 1 [23:18:27.291]
DBGRPC:       krmxcr - channel default resetted

DBGSQL:       TARGET> select decode(open_mode, 'MOUNTED', 0, 'READ WRITE', 1, 'READ ONLY', 1, 'READ ONLY WITH APPLY', 1, 0) into :isdbopen from v$database
DBGSQL:          sqlcode = 0
DBGSQL:           D :isdbopen = 1
DBGMISC:      krmqacen() [23:18:27.452]
DBGMISC:      krmqacen() : Exit [23:18:27.452]
DBGRPC:       krmxcd - removing context for channel default, keep=0
DBGRPC:       krmxcd - closing target default connection
DBGMISC:      ENTERED krmkmrsr [23:18:27.453]
DBGMISC:      EXITED krmkmrsr [23:18:27.454] elapsed time [00:00:00:00.000]
DBGRPC:       krmxpoc - clearing channel default
DBGRPC:       krmxpocx - cleaning polling context for channel default
DBGRPC:       krmxpocx - cleaning target polling channel
DBGRPC:       krmxpocx - closing the cursor
DBGRPC:       krmxpocx - logging off from oracle
DBGRPC:       krmxpocx - freeing krmxpon
DBGRPC:       krmxpocx - target polling channel cleaned up
DBGRPC:       krmxpoc - channel default, freeing polling context
DBGRPC:       krmxcd - disconnecting
DBGMISC:      ENTERED krmksimronly [23:18:27.459]
DBGMISC:      EXITED krmksimronly [23:18:27.459] elapsed time [00:00:00:00.000]
DBGRPC:       krmxcd - context removed
DBGMISC:      ENTERED krmksimronly [23:18:28.108]
DBGMISC:      EXITED krmksimronly [23:18:28.109] elapsed time [00:00:00:00.000]

DBGSQL:       CHANNEL> select sys_context('userenv', 'con_id'), sys_context('userenv', 'cdb_name'), sys_context('userenv', 'con_name'), case when sys_context('userenv', 'is_application_root') = 'YES' then 1 else 0 end into :pdbid, :cdbname, :pdbname, :approot from dual
DBGSQL:          sqlcode = 0
DBGSQL:           D :pdbid = 1
DBGSQL:           D :cdbname = TRMAN01
DBGSQL:           D :pdbname = CDB$ROOT
DBGSQL:           D :approot = 0

DBGSQL:       CHANNEL> select decode(upper(value), 'TRUE', 1, 0)   into :parmvalue   from v$parameter  where lower(name) = '_pdb_name_case_sensitive'
DBGSQL:          sqlcode = 1403
DBGMISC:      ENTERED krmksimronly [23:18:28.229]
DBGMISC:      EXITED krmksimronly [23:18:28.229] elapsed time [00:00:00:00.000]

DBGSQL:       CHANNEL> select sys_context('userenv', 'con_id'), sys_context('userenv', 'cdb_name'), sys_context('userenv', 'con_name'), case when sys_context('userenv', 'is_application_root') = 'YES' then 1 else 0 end into :pdbid, :cdbname, :pdbname, :approot from dual
DBGSQL:          sqlcode = 0
DBGSQL:           D :pdbid = 1
DBGSQL:           D :cdbname = TRMAN01
DBGSQL:           D :pdbname = CDB$ROOT
DBGSQL:           D :approot = 0

DBGSQL:       CHANNEL> select decode(upper(value), 'TRUE', 1, 0)   into :parmvalue   from v$parameter  where lower(name) = '_pdb_name_case_sensitive'
DBGSQL:          sqlcode = 1403
DBGMISC:      ENTERED krmkcrsr [23:18:28.267]
DBGRPC:        krmxcc - entering
DBGRPC:        krmxcc - creating context for channel No-chid
DBGRPC:        krmxcc - connecting using target default channel
DBGRPC:        krmxcc - seting up for out-of-band
DBGRPC:        krmxpos - setting up channel No-chid
DBGRPC:        krmxpos - creating polling channel for channel No-chid
DBGMISC:       ENTERED krmksimronly [23:18:28.375]
DBGMISC:       EXITED krmksimronly [23:18:28.376] elapsed time [00:00:00:00.000]

DBGSQL:        CHANNEL> select sys_context('userenv', 'con_id'), sys_context('userenv', 'cdb_name'), sys_context('userenv', 'con_name'), case when sys_context('userenv', 'is_application_root') = 'YES' then 1 else 0 end into :pdbid, :cdbname, :pdbname, :approot from dual
DBGSQL:           sqlcode = 0
DBGSQL:            D :pdbid = 1
DBGSQL:            D :cdbname = TRMAN01
DBGSQL:            D :pdbname = CDB$ROOT
DBGSQL:            D :approot = 0

DBGSQL:        CHANNEL> select decode(upper(value), 'TRUE', 1, 0)   into :parmvalue   from v$parameter  where lower(name) = '_pdb_name_case_sensitive'
DBGSQL:           sqlcode = 1403
DBGRPC:        krmxpos - channel No-chid polling channel created to instance 1
DBGRPC:        krmxcc - using default sga_heap_size of 16777216
DBGRPC:        krmxcc - created context for channel No-chid
DBGMISC:       krmqopen: opening new channel context for channel default, instid 1 [23:18:28.404]
DBGRPC:        krmxcr - channel default resetted

DBGSQL:        TARGET> select decode(status, 'OPEN', 1, 0), decode(archiver, 'FAILED', 1, 0), decode(database_status, 'SUSPENDED', 1, 0) into :status, :archstuck, :dbsuspended from v$instance
DBGSQL:           sqlcode = 0
DBGSQL:            D :status = 1
DBGSQL:            D :archstuck = 0
DBGSQL:            D :dbsuspended = 0

DBGSQL:        TARGET> select decode(open_mode, 'READ WRITE', 1, 0) into :read_write from v$database
DBGSQL:           sqlcode = 0
DBGSQL:            D :read_write = 1

DBGSQL:        TARGET> select value into :vcomp_txt from  v$parameter where name = 'compatible'
DBGSQL:           sqlcode = 0
DBGSQL:            D :vcomp_txt = 19.0.0

DBGSQL:        TARGET> declare dot1st number; dot2nd number; dot3rd number; comptxt varchar2(255) := :vcomp_txt; begin comptxt := comptxt || '.0.0'; dot1st := instr(comptxt, '.', 1, 1); dot2nd := instr(comptxt, '.', 1, 2); dot3rd := instr(comptxt, '.', 1, 3); comptxt :=  lpad(substr(comptxt, 1, dot1st - 1), 2, '0') || lpad(substr(comptxt, dot1st + 1, dot2nd - dot1st - 1), 2, '0')  || lpad(substr(comptxt, dot2nd + 1, dot3rd - dot2nd - 1), 2, '0');:vcomp_ub4 := to_number(comptxt); end;
DBGSQL:           sqlcode = 0
DBGSQL:            B :vcomp_ub4 = 190000
DBGSQL:            B :vcomp_txt = 19.0.0
DBGMISC:       krmkpdbs(): vcomp_txt:19.0.0 vcomp_ub4:190000 flags:5 [23:18:28.599]

DBGSQL:        TARGET> begin :vsn_min := dbms_backup_restore.protocol_version_number_min; :rel_min := dbms_backup_restore.protocol_release_number_min; :upd_min := dbms_backup_restore.protocol_update_number_min; :cmp_min := 0; :vsn_max := dbms_backup_restore.protocol_version_number_max; :rel_max := dbms_backup_restore.protocol_release_number_max; :upd_max := dbms_backup_restore.protocol_update_number_max; :cmp_max := 0; :pkg_vsn := to_char(:vsn_max, 'fm00')||'.'|| to_char(:rel_max, 'fm00')||'.'|| to_char(:upd_max, 'fm00')||'.'|| to_char(:cmp_max, 'fm00'); end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :vsn_min = 8
DBGSQL:            B :rel_min = 0
DBGSQL:            B :upd_min = 4
DBGSQL:            B :cmp_min = 0
DBGSQL:            B :vsn_max = 19
DBGSQL:            B :rel_max = 5
DBGSQL:            B :upd_max = 0
DBGSQL:            B :cmp_max = 0
DBGSQL:            B :pkg_vsn = 19.05.00.00

DBGSQL:        TARGET> begin :cmp_min := dbms_backup_restore.protocol_component_number_min; :cmp_max := dbms_backup_restore.protocol_component_number_max; :pkg_vsn := to_char(:vsn_max, 'fm00')||'.'|| to_char(:rel_max, 'fm00')||'.'|| to_char(:upd_max, 'fm00')||'.'|| to_char(:cmp_max, 'fm00'); end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :cmp_min = 0
DBGSQL:            B :cmp_max = 0
DBGSQL:            B :pkg_vsn = 19.05.00.00
DBGSQL:            B :vsn_max = 19
DBGSQL:            B :rel_max = 5
DBGSQL:            B :upd_max = 0
DBGSQL:            B :cmp_max = 0

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 08.00.04.00
DBGSQL:            B :pkg_vsnub4 = 8000400

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 08.00.05.00
DBGSQL:            B :pkg_vsnub4 = 8000500

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 08.01.03.00
DBGSQL:            B :pkg_vsnub4 = 8010300

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 08.01.05.00
DBGSQL:            B :pkg_vsnub4 = 8010500

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 08.01.06.00
DBGSQL:            B :pkg_vsnub4 = 8010600

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 08.01.07.00
DBGSQL:            B :pkg_vsnub4 = 8010700

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 09.00.00.00
DBGSQL:            B :pkg_vsnub4 = 9000000

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 09.02.00.00
DBGSQL:            B :pkg_vsnub4 = 9020000

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 10.01.00.00
DBGSQL:            B :pkg_vsnub4 = 10010000

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 10.02.00.00
DBGSQL:            B :pkg_vsnub4 = 10020000

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 10.02.00.01
DBGSQL:            B :pkg_vsnub4 = 10020001

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 11.01.00.00
DBGSQL:            B :pkg_vsnub4 = 11010000

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 11.01.00.01
DBGSQL:            B :pkg_vsnub4 = 11010001

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 11.01.00.02
DBGSQL:            B :pkg_vsnub4 = 11010002

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 11.01.00.03
DBGSQL:            B :pkg_vsnub4 = 11010003

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 11.01.00.04
DBGSQL:            B :pkg_vsnub4 = 11010004

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 11.01.00.05
DBGSQL:            B :pkg_vsnub4 = 11010005

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 11.01.00.06
DBGSQL:            B :pkg_vsnub4 = 11010006

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 11.01.00.07
DBGSQL:            B :pkg_vsnub4 = 11010007

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 11.02.00.00
DBGSQL:            B :pkg_vsnub4 = 11020000

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 11.02.00.01
DBGSQL:            B :pkg_vsnub4 = 11020001

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 11.02.00.02
DBGSQL:            B :pkg_vsnub4 = 11020002

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 12.01.00.00
DBGSQL:            B :pkg_vsnub4 = 12010000

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 12.01.00.01
DBGSQL:            B :pkg_vsnub4 = 12010001

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 12.01.00.02
DBGSQL:            B :pkg_vsnub4 = 12010002

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 12.02.00.00
DBGSQL:            B :pkg_vsnub4 = 12020000

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 12.02.00.01
DBGSQL:            B :pkg_vsnub4 = 12020001

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 12.02.00.02
DBGSQL:            B :pkg_vsnub4 = 12020002

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = 19.05.00.00
DBGSQL:            B :pkg_vsnub4 = 19050000

DBGSQL:        TARGET> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :pkg_vsn = NULL
DBGSQL:            B :pkg_vsnub4 = NULL

DBGSQL:        TARGET> begin dbms_rcvman.setDebugOn; dbms_rcvman.dumpPkgState('Debug On'); end;
DBGSQL:           sqlcode = 0
   DBGRCVMAN: ENTERING dumpPkgState Debug On
   DBGRCVMAN: this_db_key=NULL
   DBGRCVMAN: this_dbinc_key=NULL
   DBGRCVMAN: this_reset_scn=NULL
   DBGRCVMAN: this_reset_time=NULL
   DBGRCVMAN: untilSCN=NULL
   DBGRCVMAN: untilTime=NULL
   DBGRCVMAN: getRA_completedAfter=NULL
   DBGRCVMAN: getRA_completedBefore=NULL
   DBGRCVMAN: getRA_likePattern=NULL
   DBGRCVMAN: getRA_containerMask=15
   DBGRCVMAN: getRA_actionMask=63
   DBGRCVMAN: computeRA_allRecords=0
   DBGRCVMAN: computeRA_fullBackups=1
   DBGRCVMAN: allIncarnations=0
   DBGRCVMAN: EXITING dumpPkgState Debug On

DBGSQL:        TARGET> begin sys.dbms_backup_restore.createRmanStatusRow( level        => :level, parent_id    => :pid, parent_stamp => :pts, status       => :status, command_id   => :command_id, operation    => :operation, row_id       => :row_id, row_stamp    => :row_stamp, flags        => :flags); end;
DBGSQL:           sqlcode = 0
DBGSQL:            B :row_id = 538
DBGSQL:            B :row_stamp = 1033427908
DBGSQL:            B :level = 0
DBGSQL:            B :pid = 0
DBGSQL:            B :pts = 0
DBGSQL:            B :status = 1
DBGSQL:            B :command_id = 2020-02-26T23:18:26
DBGSQL:            B :operation = RMAN
DBGSQL:            B :flags = 0
DBGMISC:      EXITED krmkcrsr [23:18:28.919] elapsed time [00:00:00:00.652]

DBGSQL:       TARGET> select db.name, dbinc.resetlogs_time, dbinc.resetlogs_change#, db.dbid, rpad(db.name, 8, 'x'), dbinc.prior_resetlogs_time, dbinc.prior_resetlogs_change#, primary_db_unique_name, db.con_dbid into :dbname, :rltime, :rlscn, :fhdbi, :pdbname, :parent_rltime, :parent_rlscn, :prim_dbuname, :con_dbid from v$database db, v$database_incarnation dbinc where dbinc.status='CURRENT'
DBGSQL:          sqlcode = 0
DBGSQL:           D :dbname = TRMAN01
DBGSQL:           D :rltime = "25-NOV-2019 13:44:18"
DBGSQL:           D :rlscn = 1
DBGSQL:           D :fhdbi = 3810649330
DBGSQL:           D :pdbname = TRMAN01x
DBGSQL:           D :parent_rltime = NULL
DBGSQL:           D :parent_rlscn = 0
DBGSQL:           D :prim_dbuname = NULL
DBGSQL:           D :con_dbid = 3810649330

DBGSQL:       TARGET> select nvl(max(cpmid), '0'), nvl(max(cpmid), 0) into :txtparmvalue, :parmvalue from x$kcccp where cpsta in (2,3)
DBGSQL:          sqlcode = 0
DBGSQL:           D :txtparmvalue = 3818754911
DBGSQL:           D :parmvalue = 3818754911

DBGSQL:       TARGET> select upper(value) into :parmvalue from v$parameter where lower(name) = 'db_unique_name'
DBGSQL:          sqlcode = 0
DBGSQL:           D :parmvalue = TRMAN01

DBGSQL:       TARGET> select count(*) into :dbstate from v$parameter where lower(name) = '_dummy_instance' and upper(value) = 'TRUE'
DBGSQL:          sqlcode = 0
DBGSQL:           D :dbstate = 0

DBGSQL:       TARGET> select decode(value, 'TRUE', 1, 0) into :dbstate from v$option where parameter = 'Parallel backup and recovery'
DBGSQL:          sqlcode = 0
DBGSQL:           D :dbstate = 1

DBGSQL:       TARGET> select decode(value, 'TRUE', 1, 0) into :dbstate from v$option where parameter = 'Incremental backup and recovery'
DBGSQL:          sqlcode = 0
DBGSQL:           D :dbstate = 1

DBGSQL:       TARGET> select decode(value, 'TRUE', 1, 0) into :dbstate from v$option where parameter = 'Duplexed backups'
DBGSQL:          sqlcode = 0
DBGSQL:           D :dbstate = 1

DBGSQL:       TARGET> select decode(value, 'TRUE', 1, 0) into :dbstate from v$option where parameter = 'Block Media Recovery'
DBGSQL:          sqlcode = 0
DBGSQL:           D :dbstate = 1

DBGSQL:       TARGET> select decode(value, 'TRUE', 1, 0) into :dbstate from v$option where parameter = 'Point-in-time tablespace recovery'
DBGSQL:          sqlcode = 0
DBGSQL:           D :dbstate = 1

DBGSQL:       TARGET> select decode(value, 'TRUE', 1, 0) into :dbstate from v$option where parameter = 'Backup Encryption'
DBGSQL:          sqlcode = 0
DBGSQL:           D :dbstate = 1
DBGRCV:      EXITED krmkgetdb with status 1
RMAN-06005: connected to target database: TRMAN01 (DBID=3810649330)
DBGMISC:     ENTERED krmkjcl [23:18:29.000]
DBGMISC:     EXITED krmkjcl [23:18:29.001] elapsed time [00:00:00:00.000]
DBGMISC:    EXITED krmice [23:18:29.001] elapsed time [00:00:00:02.153]


DBGSQL:     TARGET> select decode(status, 'OPEN', 1, 0), decode(archiver, 'FAILED', 1, 0), decode(database_status, 'SUSPENDED', 1, 0) into :status, :archstuck, :dbsuspended from v$instance
DBGSQL:        sqlcode = 0
DBGSQL:         D :status = 1
DBGSQL:         D :archstuck = 0
DBGSQL:         D :dbsuspended = 0

DBGSQL:     TARGET> select decode(open_mode, 'READ WRITE', 1, 0) into :read_write from v$database
DBGSQL:        sqlcode = 0
DBGSQL:         D :read_write = 1

DBGSQL:     TARGET> select value into :vcomp_txt from  v$parameter where name = 'compatible'
DBGSQL:        sqlcode = 0
DBGSQL:         D :vcomp_txt = 19.0.0

DBGSQL:     TARGET> declare dot1st number; dot2nd number; dot3rd number; comptxt varchar2(255) := :vcomp_txt; begin comptxt := comptxt || '.0.0'; dot1st := instr(comptxt, '.', 1, 1); dot2nd := instr(comptxt, '.', 1, 2); dot3rd := instr(comptxt, '.', 1, 3); comptxt :=  lpad(substr(comptxt, 1, dot1st - 1), 2, '0') || lpad(substr(comptxt, dot1st + 1, dot2nd - dot1st - 1), 2, '0')  || lpad(substr(comptxt, dot2nd + 1, dot3rd - dot2nd - 1), 2, '0');:vcomp_ub4 := to_number(comptxt); end;
DBGSQL:        sqlcode = 0
DBGSQL:         B :vcomp_ub4 = 190000
DBGSQL:         B :vcomp_txt = 19.0.0
DBGMISC:    krmkpdbs(): vcomp_txt:19.0.0 vcomp_ub4:190000 flags:5 [23:18:29.030]
RMAN> 2> 

DBGMISC:    Node # 1 [23:18:29.036]
DBGMISC:    RCV
DBGMISC:      1 TSLIST
DBGMISC:          1 TSSPEC
DBGMISC:              1 PDBNAME = TSPITR
DBGMISC:              2 TSNAME = users
DBGMISC:      2 UNTILCL
DBGMISC:          1 TIME = to_date('26.02.2020 23:17:23','DD.MM.YYYY HH24:MI:SS')
DBGMISC:    ENTERED krmice [23:18:29.039]
DBGMISC:     command to be compiled and executed is: recover  [23:18:29.039] (krmice)
DBGMISC:     command after this command is: NONE  [23:18:29.040] (krmice)
DBGMISC:     current incarnation must match for recover  [23:18:29.040] (krmice)
DBGMISC:     ENTERED krmkcrsr [23:18:29.041]
DBGMISC:      pending krmkcrsr after auto channels allcoated with input_level 1, level 1 [23:18:29.041] (krmkcrsr)
DBGMISC:     EXITED krmkcrsr [23:18:29.041] elapsed time [00:00:00:00.000]
RMAN-03090: Starting recover at 26-FEB-2020 23:18:29
DBGMISC:     ENTERED krmicomp [23:18:29.044]

DBGSQL:       TARGET> select controlfile_type, controlfile_change#, controlfile_sequence#, controlfile_created, decode(offr.records_used, 0, 0, offr.last_recid - offr.records_used + 1), decode(database_role, 'SNAPSHOT STANDBY', 1, 0) into :cftype, :cfscn, :cfseq, :cfcretime, :cfoffrrid, :cfsnapstby from v$database, v$controlfile_record_section offr where offr.type = 'OFFLINE RANGE'
DBGSQL:          sqlcode = 0
DBGSQL:           D :cftype = CURRENT
DBGSQL:           D :cfscn = 2377060
DBGSQL:           D :cfseq = 15707
DBGSQL:           D :cfcretime = "25-NOV-2019 13:44:18"
DBGSQL:           D :cfoffrrid = 1
DBGSQL:           D :cfsnapstby = 0
DBGANY:       trying implicit resync before compiling command recover [23:18:29.053]
DBGMISC:      ENTERED krmknrsn [23:18:29.054]

DBGSQL:        TARGET> select  nvl(max(al.recid), '0'),nvl(max(al.recid), 0)   into  :txtparmvalue, :parmvalue   from  v$archived_log al  where  al.status in ('X', 'A')    and  al.is_recovery_dest_file = 'YES'    and  al.creator = 'RMAN'
DBGSQL:           sqlcode = 0
DBGSQL:            D :txtparmvalue = 0
DBGSQL:            D :parmvalue = 0

DBGSQL:        TARGET> select db.version_time, db.controlfile_change#, db.controlfile_sequence#, dbinc.resetlogs_time, df.last_recid, tf.last_recid, ts.last_recid, rl.last_recid, rm.last_recid, dc.last_recid, al.last_recid, bp.last_recid, do.last_recid, offr.last_recid, pc.last_recid, bs.last_recid, ldbinc.resetlogs_change#, ldbinc.resetlogs_time, ic.last_recid, rt.last_recid, grsp.last_recid, nrsp.last_recid, bcr.last_recid, pdb.last_recid, pic.last_recid, decode(dc.records_used, 0, 0, dc.last_recid - dc.records_used + 1), decode(al.records_used, 0, 0, al.last_recid - al.records_used + 1), decode(bp.records_used, 0, 0, bp.last_recid - bp.records_used + 1), decode(bs.records_used, 0, 0, bs.last_recid - bs.records_used + 1), decode(do.records_used, 0, 0, do.last_recid - do.records_used + 1), decode(offr.records_used, 0, 0, offr.last_recid - offr.records_used + 1), decode(pc.records_used, 0, 0, pc.last_recid - pc.records_used + 1) into   :vertime, :cfscn, :cfseq, :rltime, :dfhwm, :tfhwm, :tshwm, :rlhwm, :rmhwm, :dchwm, :alhwm, :bphwm, :dohwm, :offrhwm, :pchwm, :bshwm, :lrstscn, :lrsttime, :ichwm, :rthwm, :grsphwm, :nrsphwm, :bcrhwm, :pdbhwm, :pichwm, :dclwm, :allwm, :bplwm, :bslwm, :dolwm, :offrlwm, :pclwm from   v$database db, v$controlfile_record_section df, v$controlfile_record_section tf, v$controlfile_record_section ts, v$controlfile_record_section rt, v$controlfile_record_section rl, v$controlfile_record_section rm, v$controlfile_record_section dc, v$controlfile_record_section al, v$controlfile_record_section bp, v$controlfile_record_section do, v$controlfile_record_section offr, v$controlfile_record_section pc, v$controlfile_record_section bs, v$controlfile_record_section ic, v$controlfile_record_section grsp, v$controlfile_record_section nrsp, v$controlfile_record_section bcr, v$controlfile_record_section pdb, v$controlfile_record_section pic, v$database_incarnation dbinc, v$database_incarnation ldbinc where df.type   = 'DATAFILE' and   tf.type   = 'TEMPORARY FILENAME' and   ts.type   = 'TABLESPACE' and   rt.type   = 'REDO THREAD' and   rl.type   = 'REDO LOG' and   rm.type   = 'RMAN CONFIGURATION' and   dc.type   = 'DATAFILE COPY' and   al.type   = 'ARCHIVED LOG' and   bp.type   = 'BACKUP PIECE' and   do.type   = 'DELETED OBJECT' and   offr.type = 'OFFLINE RANGE' and   pc.type   = 'PROXY COPY' and   bs.type   = 'BACKUP SET' and   ic.type   = 'DATABASE INCARNATION' and   grsp.type = 'GUARANTEED RESTORE POINT' and   nrsp.type = 'RESTORE POINT' and   bcr.type  = 'DATABASE BLOCK CORRUPTION' and   pdb.type  = 'PDB RECORD' and   pic.type  = 'PDBINC RECORD' and   dbinc.incarnation#=db.recovery_target_incarnation# and   ldbinc.incarnation#=db.last_open_incarnation#
DBGSQL:           sqlcode = 0
DBGSQL:            D :vertime = "25-NOV-2019 13:44:18"
DBGSQL:            D :cfscn = 2377060
DBGSQL:            D :cfseq = 15707
DBGSQL:            D :rltime = "25-NOV-2019 13:44:18"
DBGSQL:            D :dfhwm = 872
DBGSQL:            D :tfhwm = 140
DBGSQL:            D :tshwm = 431
DBGSQL:            D :rlhwm = 3
DBGSQL:            D :rmhwm = 0
DBGSQL:            D :dchwm = 0
DBGSQL:            D :alhwm = 375
DBGSQL:            D :bphwm = 240
DBGSQL:            D :dohwm = 855
DBGSQL:            D :offrhwm = 129
DBGSQL:            D :pchwm = 0
DBGSQL:            D :bshwm = 240
DBGSQL:            D :lrstscn = 1
DBGSQL:            D :lrsttime = "25-NOV-2019 13:44:18"
DBGSQL:            D :ichwm = 1
DBGSQL:            D :rthwm = 0
DBGSQL:            D :grsphwm = 0
DBGSQL:            D :nrsphwm = 0
DBGSQL:            D :bcrhwm = 0
DBGSQL:            D :pdbhwm = 140
DBGSQL:            D :pichwm = 0
DBGSQL:            D :dclwm = 0
DBGSQL:            D :allwm = 96
DBGSQL:            D :bplwm = 1
DBGSQL:            D :bslwm = 1
DBGSQL:            D :dolwm = 38
DBGSQL:            D :offrlwm = 1
DBGSQL:            D :pclwm = 0
DBGMISC:       resync=3, newbck=0, needref=0 [23:18:29.092] (krmknrsn)
DBGMISC:      EXITED krmknrsn [23:18:29.093] elapsed time [00:00:00:00.039]

DBGSQL:       TARGET> select count(*) into :dbstate from v$archive_dest where dest_id <= 10  and destination = 'USE_DB_RECOVERY_FILE_DEST' and status = 'VALID'
DBGSQL:          sqlcode = 0
DBGSQL:           D :dbstate = 1

DBGSQL:       TARGET> declare savail_bytes number; begin  select (space_limit - space_used + space_reclaimable) into savail_bytes from v$recovery_file_dest; if (sign(savail_bytes) > 0) then :savail := floor(savail_bytes * :amount/100); else :savail := 0; end if; end;
DBGSQL:          sqlcode = 0
DBGSQL:           B :savail = 3399413376
DBGSQL:           B :amount = 75
DBGRCV:       ENTERED krmkucls
DBGRCV:        ENTERED krmkinvalnewnames
DBGRCV:        EXITED krmkinvalnewnames
DBGRCV:       EXITED krmkucls with address 140548062548896
DBGTSPITR:    ENTERED krmrDoTspitr

DBGSQL:        TARGET> select decode(open_mode, 'READ WRITE', 1, 0) into :dbstate from V$DATABASE
DBGSQL:           sqlcode = 0
DBGSQL:            D :dbstate = 1

DBGSQL:        TARGET> select decode(LOG_MODE, 'ARCHIVELOG', 1, 'MANUAL', 1, 0) into :dbstate from V$DATABASE
DBGSQL:           sqlcode = 0
DBGSQL:            D :dbstate = 1
RMAN-06009: using target database control file instead of recovery catalog
DBGRPC:        krmxcd - removing context for channel default, keep=2
DBGRPC:        krmxpoc - clearing channel default
DBGRPC:        krmxpocx - cleaning polling context for channel default
DBGRPC:        krmxpocx - cleaning target polling channel
DBGRPC:        krmxpocx - closing the cursor
DBGRPC:        krmxpocx - logging off from oracle
DBGRPC:        krmxpocx - freeing krmxpon
DBGRPC:        krmxpocx - target polling channel cleaned up
DBGRPC:        krmxpoc - channel default, freeing polling context
DBGRPC:        krmxcd - disconnecting
DBGRPC:        krmxcd - context removed
DBGRPC:        krmxcc - entering
DBGRPC:        krmxcc - creating context for channel No-chid
DBGRPC:        krmxcc - connecting using target default channel
DBGRPC:        krmxcc - seting up for out-of-band
DBGRPC:        krmxpos - setting up channel No-chid
DBGRPC:        krmxpos - creating polling channel for channel No-chid
DBGMISC:       ENTERED krmksimronly [23:18:29.324]
DBGMISC:       EXITED krmksimronly [23:18:29.324] elapsed time [00:00:00:00.000]

DBGSQL:        CHANNEL> select sys_context('userenv', 'con_id'), sys_context('userenv', 'cdb_name'), sys_context('userenv', 'con_name'), case when sys_context('userenv', 'is_application_root') = 'YES' then 1 else 0 end into :pdbid, :cdbname, :pdbname, :approot from dual
DBGSQL:           sqlcode = 0
DBGSQL:            D :pdbid = 1
DBGSQL:            D :cdbname = TRMAN01
DBGSQL:            D :pdbname = CDB$ROOT
DBGSQL:            D :approot = 0

DBGSQL:        CHANNEL> select decode(upper(value), 'TRUE', 1, 0)   into :parmvalue   from v$parameter  where lower(name) = '_pdb_name_case_sensitive'
DBGSQL:           sqlcode = 1403
DBGRPC:        krmxpos - channel No-chid polling channel created to instance 1
DBGRPC:        krmxcc - using default sga_heap_size of 16777216
DBGRPC:        krmxcc - created context for channel No-chid
DBGMISC:       krmqopen: opening new channel context for channel default, instid 1 [23:18:29.364]
DBGRPC:        krmxcr - channel default resetted

DBGSQL:        TARGET> begin :nobackup := dbms_rcvman.isNoBackupPdb( pdbname => :pdbname_in); end;
DBGSQL:           sqlcode = 0
DBGSQL:            B :nobackup = 0
DBGSQL:            B :pdbname_in = TSPITR
   DBGRCVMAN: ENTERING isNoBackupPdb
   DBGRCVMAN: EXITING isNoBackupPdb with 0
DBGTSPITR:       1 TSLIST
DBGTSPITR:           1 TSSPEC
DBGTSPITR:               1 PDBNAME = TSPITR
DBGTSPITR:               2 TSNAME = users
DBGTSPITR:       2 UNTILCL
DBGTSPITR:           1 TIME = to_date('26.02.2020 23:17:23','DD.MM.YYYY HH24:MI:SS')

DBGSQL:        TARGET> select con_name_to_id(:pdbname_in) from dual
DBGSQL:           sqlcode = 0
DBGSQL:            D :pdbid = 6
DBGSQL:            B :pdbname_in = TSPITR

DBGSQL:        TARGET> select decode(APPLICATION_PDB, 'YES', 1, 0) into :apppdb from gv$pdbs where name=:pdbnam
DBGSQL:           sqlcode = 0
DBGSQL:            D :apppdb = 0
DBGSQL:            B :pdbnam = TSPITR

DBGSQL:        TARGET> select APPLICATION_ROOT_CON_ID into :app_root_id from v$pdbs where name = :pdbnam 
DBGSQL:           sqlcode = 0
DBGSQL:            D :app_root_id = NULL
DBGSQL:            B :pdbnam = TSPITR

DBGSQL:        TARGET> begin :rval := dbms_backup_restore.canKeepDatafiles;end;
DBGSQL:           sqlcode = 0
DBGSQL:            B :rval = 1
DBGDUP:        ENTERED krmkgmaxscn
DBGMISC:        ENTERED krmksetdb [23:18:29.588]

DBGSQL:          TARGET> select controlfile_type, controlfile_change#, controlfile_sequence#, controlfile_created, decode(offr.records_used, 0, 0, offr.last_recid - offr.records_used + 1), decode(database_role, 'SNAPSHOT STANDBY', 1, 0) into :cftype, :cfscn, :cfseq, :cfcretime, :cfoffrrid, :cfsnapstby from v$database, v$controlfile_record_section offr where offr.type = 'OFFLINE RANGE'
DBGSQL:             sqlcode = 0
DBGSQL:              D :cftype = CURRENT
DBGSQL:              D :cfscn = 2377060
DBGSQL:              D :cfseq = 15707
DBGSQL:              D :cfcretime = "25-NOV-2019 13:44:18"
DBGSQL:              D :cfoffrrid = 1
DBGSQL:              D :cfsnapstby = 0
DBGMISC:         ENTERED krmkgetdb [23:18:29.599]

DBGSQL:           TARGET> select db.name, dbinc.resetlogs_time, dbinc.resetlogs_change#, db.dbid, rpad(db.name, 8, 'x'), dbinc.prior_resetlogs_time, dbinc.prior_resetlogs_change#, primary_db_unique_name, db.con_dbid into :dbname, :rltime, :rlscn, :fhdbi, :pdbname, :parent_rltime, :parent_rlscn, :prim_dbuname, :con_dbid from v$database db, v$database_incarnation dbinc where dbinc.status='CURRENT'
DBGSQL:              sqlcode = 0
DBGSQL:               D :dbname = TRMAN01
DBGSQL:               D :rltime = "25-NOV-2019 13:44:18"
DBGSQL:               D :rlscn = 1
DBGSQL:               D :fhdbi = 3810649330
DBGSQL:               D :pdbname = TRMAN01x
DBGSQL:               D :parent_rltime = NULL
DBGSQL:               D :parent_rlscn = 0
DBGSQL:               D :prim_dbuname = NULL
DBGSQL:               D :con_dbid = 3810649330

DBGSQL:           TARGET> select nvl(max(cpmid), '0'), nvl(max(cpmid), 0) into :txtparmvalue, :parmvalue from x$kcccp where cpsta in (2,3)
DBGSQL:              sqlcode = 0
DBGSQL:               D :txtparmvalue = 3818754911
DBGSQL:               D :parmvalue = 3818754911

DBGSQL:           TARGET> select upper(value) into :parmvalue from v$parameter where lower(name) = 'db_unique_name'
DBGSQL:              sqlcode = 0
DBGSQL:               D :parmvalue = TRMAN01

DBGSQL:           TARGET> select count(*) into :dbstate from v$parameter where lower(name) = '_dummy_instance' and upper(value) = 'TRUE'
DBGSQL:              sqlcode = 0
DBGSQL:               D :dbstate = 0

DBGSQL:           TARGET> select decode(value, 'TRUE', 1, 0) into :dbstate from v$option where parameter = 'Parallel backup and recovery'
DBGSQL:              sqlcode = 0
DBGSQL:               D :dbstate = 1

DBGSQL:           TARGET> select decode(value, 'TRUE', 1, 0) into :dbstate from v$option where parameter = 'Incremental backup and recovery'
DBGSQL:              sqlcode = 0
DBGSQL:               D :dbstate = 1

DBGSQL:           TARGET> select decode(value, 'TRUE', 1, 0) into :dbstate from v$option where parameter = 'Duplexed backups'
DBGSQL:              sqlcode = 0
DBGSQL:               D :dbstate = 1

DBGSQL:           TARGET> select decode(value, 'TRUE', 1, 0) into :dbstate from v$option where parameter = 'Block Media Recovery'
DBGSQL:              sqlcode = 0
DBGSQL:               D :dbstate = 1

DBGSQL:           TARGET> select decode(value, 'TRUE', 1, 0) into :dbstate from v$option where parameter = 'Point-in-time tablespace recovery'
DBGSQL:              sqlcode = 0
DBGSQL:               D :dbstate = 1

DBGSQL:           TARGET> select decode(value, 'TRUE', 1, 0) into :dbstate from v$option where parameter = 'Backup Encryption'
DBGSQL:              sqlcode = 0
DBGSQL:               D :dbstate = 1
DBGRCV:          EXITED krmkgetdb with status 1
DBGMISC:         Calling dbms_rcvman.setDatabase [23:18:29.674] (krmksetdb)

DBGSQL:          TARGET> begin dbms_rcvman.setDatabase( db_name        => upper(:dbname), reset_scn      => :rlscn, reset_time     => :rltime, db_id          => :fhdbi, db_unique_name => :db_unique_name, site_aware     => TRUE, guid           => :guid); dbms_rcvman.setCanApplyAnyRedo(TRUE); dbms_rcvman.setCanConvertCf(TRUE); dbms_rcvman.setBigScnAware; if (:canhandletts = 1) then   dbms_rcvman.setCanHandleTransportableTbs(TRUE); end if; end; 
DBGSQL:             sqlcode = 0
DBGSQL:              B :dbname = TRMAN01
DBGSQL:              B :rlscn = 1
DBGSQL:              B :rltime = "25-NOV-2019 13:44:18"
DBGSQL:              B :fhdbi = 3810649330
DBGSQL:              B :db_unique_name = TRMAN01
DBGSQL:              B :canhandletts = 1
DBGSQL:              B :guid = NULL
     DBGRCVMAN: Fetching incarnation records
     DBGRCVMAN: incarnation record id=0
     DBGRCVMAN: icprs=0,icprc=
     DBGRCVMAN: icrls=1,icrlc=25-NOV-2019 13:44:18
     DBGRCVMAN: icrlc_i=1025271858
     DBGRCVMAN: icpinc=0
     DBGRCVMAN: icflg=CURRENT
     DBGRCVMAN: number of incarnation=1
     DBGRCVMAN: Fetching pdb sub incarnation records
     DBGRCVMAN: incarnation record id=0
     DBGRCVMAN: con_id=1,pdbinc_key=0
     DBGRCVMAN: incscn=1,erscn=1
     DBGRCVMAN: status=CURRENT
     DBGRCVMAN: incarnation record id=0
     DBGRCVMAN: con_id=2,pdbinc_key=0
     DBGRCVMAN: incscn=1,erscn=1
     DBGRCVMAN: status=CURRENT
     DBGRCVMAN: incarnation record id=0
     DBGRCVMAN: con_id=3,pdbinc_key=0
     DBGRCVMAN: incscn=1,erscn=1
     DBGRCVMAN: status=CURRENT
     DBGRCVMAN: incarnation record id=0
     DBGRCVMAN: con_id=6,pdbinc_key=0
     DBGRCVMAN: incscn=1,erscn=1
     DBGRCVMAN: status=CURRENT
     DBGRCVMAN: canApplyAnyRedo is set to TRUE
     DBGRCVMAN: canConvert_Cf is set to TRUE
     DBGRCVMAN: Database is BIGSCN aware, higscnval set to UB8MAXVAL
     DBGRCVMAN: canHandleTransportableTbs is set to TRUE
DBGMISC:        EXITED krmksetdb [23:18:29.773] elapsed time [00:00:00:00.184]

DBGSQL:         TARGET> begin    :lscn := dbms_rcvman.getMaxScn(:ltime); end;
DBGSQL:            sqlcode = 0
DBGSQL:             B :lscn = 2377021
DBGSQL:             B :ltime = "26-FEB-2020 23:17:31"
    DBGRCVMAN: ENTERING getMaxScn
    DBGRCVMAN:    getMaxScn Controlfile type = CURRENT
    DBGRCVMAN: Controlfile_change# :2377060
    DBGRCVMAN: CHECKPOINT_CHANGE# :2376961
    DBGRCVMAN: Max from v$archived_log: 2377021
    DBGRCVMAN: Max from v$archived_log: 26-FEB-2020 23:17:31
    DBGRCVMAN: Number of archivelogs: 280
    DBGRCVMAN: EXITING getMaxScn with minmaxnc=2377021 and minmaxnt=26-FEB-2020 23:17:31
DBGDUP:        EXITED krmkgmaxscn

DBGSQL:        TARGET> select to_date('26.02.2020 23:17:23','DD.MM.YYYY HH24:MI:SS') from sys.dual
DBGSQL:           sqlcode = 0
DBGSQL:            D :mydate = "26-FEB-2020 23:17:23"

DBGSQL:        TARGET> select to_date('26.02.2020 23:17:23','DD.MM.YYYY HH24:MI:SS') from sys.dual
DBGSQL:           sqlcode = 0
DBGSQL:            D :mydate = "26-FEB-2020 23:17:23"

DBGSQL:        TARGET> begin  :approot := dbms_rcvman.isPdbApplicationRoot(                                   :pdbnam, :guid); end; 
DBGSQL:           sqlcode = 0
DBGSQL:            B :approot = 0
DBGSQL:            B :guid = 9F83CA688D186D6FE053030011AC1BBD
DBGSQL:            B :pdbnam = TSPITR
   DBGRCVMAN: ENTERING isPdbApplicationRoot
   DBGRCVMAN: EXITING isPdbApplicationRoot with 0
DBGMISC:       krmqacrd() : read channel configuration [23:18:29.982]
DBGMISC:       ENTERED krmkgconf [23:18:29.982]
DBGMISC:        krmkgconf: Configuration is DEVICE TYPE [23:18:29.983] (krmkgconf)

DBGSQL:         TARGET> declare first boolean; conf# number; begin if (:first > 0) then first := TRUE; else first := FALSE; end if; dbms_rcvman.getConfig(conf#, :name, :value, first); end;
DBGSQL:            sqlcode = 1403
DBGSQL:             B :first = 1
DBGSQL:             B :name = DEVICE TYPE
DBGSQL:             B :value = NULL
DBGMISC:        Function krmkgconf created the following tree:EXIT
DBGMISC:       EXITED krmkgconf [23:18:29.995] elapsed time [00:00:00:00.013]
DBGMISC:       ENTERED krmkgdconf [23:18:29.996]
DBGMISC:        inp devtype=null [23:18:29.997] (krmkgdconf)
DBGMISC:        ENTERED krmkgconf [23:18:29.997]
DBGMISC:         krmkgconf: Configuration is DEFAULT DEVICE TYPE TO [23:18:29.998] (krmkgconf)

DBGSQL:          TARGET> declare first boolean; conf# number; begin if (:first > 0) then first := TRUE; else first := FALSE; end if; dbms_rcvman.getConfig(conf#, :name, :value, first); end;
DBGSQL:             sqlcode = 1403
DBGSQL:              B :first = 1
DBGSQL:              B :name = DEFAULT DEVICE TYPE TO
DBGSQL:              B :value = NULL
DBGMISC:         Function krmkgconf created the following tree:EXIT
DBGMISC:        EXITED krmkgconf [23:18:30.010] elapsed time [00:00:00:00.012]
DBGMISC:        DEFAULTDEV
DBGMISC:          1 CHDISK
DBGMISC:       EXITED krmkgdconf [23:18:30.012] elapsed time [00:00:00:00.015]
DBGMISC:       ENTERED krmkgconf [23:18:30.012]
DBGMISC:        krmkgconf: Configuration is CHANNEL [23:18:30.013] (krmkgconf)

DBGSQL:         TARGET> declare first boolean; conf# number; begin if (:first > 0) then first := TRUE; else first := FALSE; end if; dbms_rcvman.getConfig(conf#, :name, :value, first); end;
DBGSQL:            sqlcode = 1403
DBGSQL:             B :first = 1
DBGSQL:             B :name = CHANNEL
DBGSQL:             B :value = NULL
DBGMISC:        Function krmkgconf created the following tree:EXIT
DBGMISC:       EXITED krmkgconf [23:18:30.023] elapsed time [00:00:00:00.010]
DBGMISC:       ENTERED krmkgconf [23:18:30.024]
DBGMISC:        krmkgconf: Configuration is AUXILIARY CHANNEL [23:18:30.024] (krmkgconf)

DBGSQL:         TARGET> declare first boolean; conf# number; begin if (:first > 0) then first := TRUE; else first := FALSE; end if; dbms_rcvman.getConfig(conf#, :name, :value, first); end;
DBGSQL:            sqlcode = 1403
DBGSQL:             B :first = 1
DBGSQL:             B :name = AUXILIARY CHANNEL
DBGSQL:             B :value = NULL
DBGMISC:        Function krmkgconf created the following tree:EXIT
DBGMISC:       EXITED krmkgconf [23:18:30.033] elapsed time [00:00:00:00.009]
DBGMISC:       krmqcons() :clone 0, device DISK, channel 0
DBGMISC:       krmqcons() :Set default configuration [23:18:30.034]
DBGMISC:       krmqcons() : Exit [23:18:30.035]
DBGMISC:       krmqcons() :clone 0, device DISK, channel 1
DBGMISC:       krmqcons() :use default channel configuration [23:18:30.036]
DBGMISC:       krmqcons() : Exit [23:18:30.036]
DBGMISC:       krmqcons() :clone 1, device DISK, channel 0
DBGMISC:       krmqcons() : Exit [23:18:30.038]
DBGMISC:       krmqcons() :clone 1, device DISK, channel 1
DBGMISC:       krmqdupc() :duplicate ORA_DISK_1 channel [23:18:30.039]
DBGMISC:       krmqdupc() : Exit [23:18:30.039]
DBGMISC:       krmqcons() : Exit [23:18:30.040]
DBGMISC:       krmqacrd() : Exit [23:18:30.041]
DBGMISC:       krmqalc1() :clone 0, device DISK, allocated = 0, need = 65535
DBGMISC:       krmqacdi() [23:18:30.042]
DBGMISC:       krmqacdi() : Exit [23:18:30.043]
DBGMISC:       krmqalc1() :allocating channels for DISK [23:18:30.043]

DBGMISC:       Node # 1 [23:18:30.044]
DBGMISC:       CHALLOC
DBGMISC:         1 CHID = ORA_DISK_1
DBGMISC:         2 CHDISK
DBGMISC:       ENTERED krmice [23:18:30.047]
DBGMISC:        command to be compiled and executed is: allocate  [23:18:30.047] (krmice)
DBGMISC:        command after this command is: NONE  [23:18:30.048] (krmice)
DBGMISC:        current incarnation does not matter for allocate [23:18:30.049] (krmice)
DBGMISC:        ENTERED krmicomp [23:18:30.049]
DBGMISC:         ENTERED krmkomp [23:18:30.050]
DBGRCV:           ENTERED krmkucls
DBGRCV:           EXITED krmkucls with address 0
DBGMISC:          krmkcomp - Name translation request for channel allocation - 5 [23:18:30.052] (krmkomp)
DBGMISC:          ENTERED krmknmtr [23:18:30.053]

DBGSQL:            TARGET> select decode(status, 'OPEN', 1, 0), decode(archiver, 'FAILED', 1, 0), decode(database_status, 'SUSPENDED', 1, 0) into :status, :archstuck, :dbsuspended from v$instance
DBGSQL:               sqlcode = 0
DBGSQL:                D :status = 1
DBGSQL:                D :archstuck = 0
DBGSQL:                D :dbsuspended = 0
       DBGRCVMAN: getConfig: configurations exists for this site
       DBGRCVMAN: getConfig: configurations exists for this site
       DBGRCVMAN: getConfig: configurations exists for this site
       DBGRCVMAN: getConfig: configurations exists for this site

DBGSQL:            TARGET> select decode(open_mode, 'READ WRITE', 1, 0) into :read_write from v$database
DBGSQL:               sqlcode = 0
DBGSQL:                D :read_write = 1

DBGSQL:            TARGET> select value into :vcomp_txt from  v$parameter where name = 'compatible'
DBGSQL:               sqlcode = 0
DBGSQL:                D :vcomp_txt = 19.0.0

DBGSQL:            TARGET> declare dot1st number; dot2nd number; dot3rd number; comptxt varchar2(255) := :vcomp_txt; begin comptxt := comptxt || '.0.0'; dot1st := instr(comptxt, '.', 1, 1); dot2nd := instr(comptxt, '.', 1, 2); dot3rd := instr(comptxt, '.', 1, 3); comptxt :=  lpad(substr(comptxt, 1, dot1st - 1), 2, '0') || lpad(substr(comptxt, dot1st + 1, dot2nd - dot1st - 1), 2, '0')  || lpad(substr(comptxt, dot2nd + 1, dot3rd - dot2nd - 1), 2, '0');:vcomp_ub4 := to_number(comptxt); end;
DBGSQL:               sqlcode = 0
DBGSQL:                B :vcomp_ub4 = 190000
DBGSQL:                B :vcomp_txt = 19.0.0
DBGMISC:           krmkpdbs(): vcomp_txt:19.0.0 vcomp_ub4:190000 flags:5 [23:18:30.113]
DBGRCV:            ENTERED krmkicat
DBGRCV:             host=TARGET, transclause: 0, needuntscn: 0 haveuntscn: 0 (krmkicat)
DBGRCV:             Need to initialize target (krmkicat)
DBGRCV:             Need to initialize rcvcat (krmkicat)
DBGRCV:             Forced to recompute until scn due to resetAll (krmkicat)

DBGSQL:             TARGET> declare transclause boolean := FALSE; begin if (:transclause > 0) then transclause := TRUE; end if; dbms_rcvman.resetAll(transclause => transclause); end; 
DBGSQL:                sqlcode = 0
DBGSQL:                 B :transclause = 0
        DBGRCVMAN: resetAll
        DBGRCVMAN: ENTERING setRAflags
        DBGRCVMAN: setRAflags kindMask=255 containerMask=15 actionMask=63
        DBGRCVMAN:  ENTERING setComputeRecoveryActionMasks816
        DBGRCVMAN:   ENTERING setComputeRecoveryActionMasks
        DBGRCVMAN:   EXITING setComputeRecoveryActionMasks
        DBGRCVMAN:  EXITING setComputeRecoveryActionMasks816
        DBGRCVMAN: EXITING setRAflags
        DBGRCVMAN: allIncarnations is set to FALSE
        DBGRCVMAN: getRA_likePattern=
        DBGRCVMAN: restoreTag=,tag_like=0
        DBGRCVMAN: this_cftype=CURRENT
        DBGRCVMAN: this_dbrole=PRIMARY
        DBGRCVMAN: *****BsRecCache Statistics*****
        DBGRCVMAN: Cache size=0 hit=0
        DBGRCVMAN: rcvRecBackupAge= 0
        DBGRCVMAN: thisBackupAge= 0
        DBGRCVMAN: ENTERING setRedoLogDeletionPolicy
        DBGRCVMAN:    setRedoLogDeletionPolicy with policy = TO NONE
        DBGRCVMAN:    setRedoLogDeletionPolicy with alldest = 0
        DBGRCVMAN: redoLogDeletionPolicyDefValid = 1
        DBGRCVMAN:  ENTERING validateStandbyConfig1
        DBGRCVMAN: policy  = TO NONE
        DBGRCVMAN: alldest = 0
        DBGRCVMAN:  EXITING validateStandbyConfig1 with status   = 1
        DBGRCVMAN: EXITING setRedoLogDeletionPolicy with policy = TO NONE with alldest = 0

DBGSQL:             TARGET> begin :success               := dbms_rcvman.SUCCESS; :available             := dbms_rcvman.AVAILABLE; :unavailable           := dbms_rcvman.UNAVAILABLE; :restorable            := dbms_rcvman.RESTORABLE; :no_action             := dbms_rcvman.NO_ACTION; :BSavailable           := dbms_rcvman.BSavailable; :BSunavailable         := dbms_rcvman.BSunavailable; :BSdeleted             := dbms_rcvman.BSdeleted; :BSexpired             := dbms_rcvman.BSexpired; :BSpartial_avail       := dbms_rcvman.BSpartial_avail; :BSdatafile_full       := dbms_rcvman.BSdatafile_full; :BSdatafile_incr       := dbms_rcvman.BSdatafile_incr; :BSarchivelog          := dbms_rcvman.BSarchivelog; :BScfile_all           := dbms_rcvman.BScfile_all; :BScfile_auto          := dbms_rcvman.BScfile_auto; :offlineRange          := dbms_rcvman.offlineRangeRec_con_t; :proxyCopy             := dbms_rcvman.proxyCopy_con_t; :imageCopy             := dbms_rcvman.imageCopy_con_t; :backupSet             := dbms_rcvman.backupSet_con_t; :datafile              := dbms_rcvman.datafile_con_t; :addredo               := dbms_rcvman.addredo_con_t; :avmImageCopy          := dbms_rcvman.avmImageCopy_con_t; :fullAct               := dbms_rcvman.full_act_t; :incrementalAct        := dbms_rcvman.incremental_act_t; :redoAct               := dbms_rcvman.redo_act_t; :offRngAct             := dbms_rcvman.offlineRange_act_t; :implicitRangeAct      := dbms_rcvman.implicitRange_act_t; :cleanRangeAct         := dbms_rcvman.cleanRange_act_t; :createDatafileAct     := dbms_rcvman.createdatafile_act_t; :getCfCopy             := dbms_rcvman.getCfCopy; :getDfCopy             := dbms_rcvman.getDfCopy; :getAnyProxy           := dbms_rcvman.getAnyProxy; :getCfBackup           := dbms_rcvman.getCfBackup; :getSfBackup           := dbms_rcvman.getSfBackup; :listCfCopy            := dbms_rcvman.listCfCopy; :listDfCopy            := dbms_rcvman.listDfCopy; :listCfBackup          := dbms_rcvman.listCfBackup; :listSfBackup          := dbms_rcvman.listSfBackup; :listDfBackup          := dbms_rcvman.listDfBackup; :listAlBackup          := dbms_rcvman.listAlBackup; :listDfProxy           := dbms_rcvman.listDfProxy; :getRecovAction        := dbms_rcvman.getRecovAction; :getAlBackup           := dbms_rcvman.getAlBackup; :listAlCopy            := dbms_rcvman.listAlCopy; :listBSet              := dbms_rcvman.listBSet; :getAllBSet            := dbms_rcvman.getAllBSet; :listAlProxy           := dbms_rcvman.listAlProxy; :getRangeAlBackup      := dbms_rcvman.getRangeAlBackup; :unknownCmd            := dbms_rcvman.unknownCmd_t; :recoverCmd            := dbms_rcvman.recoverCmd_t; :rcvCopyCmd            := dbms_rcvman.rcvCopyCmd_t; :restoreCmd            := dbms_rcvman.restoreCmd_t; :blkRestoreCmd         := dbms_rcvman.blkRestoreCmd_t; end; 
DBGSQL:                sqlcode = 0
DBGSQL:                 B :success = 0
DBGSQL:                 B :available = 2
DBGSQL:                 B :unavailable = 1
DBGSQL:                 B :restorable = 3
DBGSQL:                 B :no_action = 4
DBGSQL:                 B :BSavailable = 1
DBGSQL:                 B :BSunavailable = 2
DBGSQL:                 B :BSdeleted = 4
DBGSQL:                 B :BSexpired = 8
DBGSQL:                 B :BSpartial_avail = 16
DBGSQL:                 B :BSdatafile_full = 1
DBGSQL:                 B :BSdatafile_incr = 2
DBGSQL:                 B :BSarchivelog = 4
DBGSQL:                 B :BScfile_all = 1
DBGSQL:                 B :BScfile_auto = 2
DBGSQL:                 B :offlineRange = 1
DBGSQL:                 B :proxyCopy = 2
DBGSQL:                 B :imageCopy = 4
DBGSQL:                 B :backupSet = 8
DBGSQL:                 B :datafile = 512
DBGSQL:                 B :addredo = 16
DBGSQL:                 B :avmImageCopy = 1024
DBGSQL:                 B :fullAct = 1
DBGSQL:                 B :incrementalAct = 2
DBGSQL:                 B :redoAct = 4
DBGSQL:                 B :offRngAct = 8
DBGSQL:                 B :implicitRangeAct = 32
DBGSQL:                 B :cleanRangeAct = 16
DBGSQL:                 B :createDatafileAct = 128
DBGSQL:                 B :getCfCopy = 0
DBGSQL:                 B :getDfCopy = 1
DBGSQL:                 B :getAnyProxy = 2
DBGSQL:                 B :getCfBackup = 3
DBGSQL:                 B :getSfBackup = 14
DBGSQL:                 B :listCfCopy = 4
DBGSQL:                 B :listDfCopy = 5
DBGSQL:                 B :listCfBackup = 6
DBGSQL:                 B :listSfBackup = 15
DBGSQL:                 B :listDfBackup = 7
DBGSQL:                 B :listAlBackup = 8
DBGSQL:                 B :listDfProxy = 9
DBGSQL:                 B :getRecovAction = 10
DBGSQL:                 B :getAlBackup = 11
DBGSQL:                 B :listAlCopy = 12
DBGSQL:                 B :listBSet = 13
DBGSQL:                 B :getAllBSet = 16
DBGSQL:                 B :listAlProxy = 17
DBGSQL:                 B :getRangeAlBackup = 18
DBGSQL:                 B :unknownCmd = 0
DBGSQL:                 B :recoverCmd = 1
DBGSQL:                 B :rcvCopyCmd = 2
DBGSQL:                 B :restoreCmd = 4
DBGSQL:                 B :blkRestoreCmd = 5
DBGANY:             No untilscn in effect [23:18:30.289] (krmkicat)
DBGRCV:            EXITED krmkicat
DBGMISC:           ENTERED krmknmtr [23:18:30.290]
DBGMISC:           EXITED krmknmtr with status CHID [23:18:30.290] elapsed time [00:00:00:00.000]
DBGMISC:           krmknmtr:  the parse tree after name translation is: [23:18:30.291] (krmknmtr)
DBGMISC:             1 CHALLOC
DBGMISC:                 1 CHID = ORA_DISK_1
DBGMISC:                 2 CHDISK
DBGMISC:          EXITED krmknmtr with status allocate [23:18:30.292] elapsed time [00:00:00:00.239]
DBGMISC:          ENTERED krmkdps [23:18:30.293]
DBGMISC:           krmkdps: this_db_key=1 [23:18:30.296]
DBGMISC:           krmkdps: this_dbinc_key=1 [23:18:30.299]
DBGMISC:           krmkdps: this_reset_scn=1 [23:18:30.302]
DBGMISC:           krmkdps: this_reset_time=25-NOV-2019 13:44:18 [23:18:30.304]
DBGMISC:           krmkdps: untilSCN=NULL [23:18:30.307]
DBGMISC:           krmkdps: untilTime=NULL [23:18:30.310]
DBGMISC:           krmkdps: getRA_completedAfter=NULL [23:18:30.312]
DBGMISC:           krmkdps: getRA_completedBefore=NULL [23:18:30.315]
DBGMISC:           krmkdps: getRA_likePattern=NULL [23:18:30.318]
DBGMISC:           krmkdps: getRA_containerMask=15 [23:18:30.321]
DBGMISC:           krmkdps: getRA_actionMask=63 [23:18:30.324]
DBGMISC:           krmkdps: computeRA_allRecords=0 [23:18:30.326]
DBGMISC:           krmkdps: computeRA_fullBackups=1 [23:18:30.329]
DBGMISC:           krmkdps: allIncarnations=0 [23:18:30.332]
DBGMISC:          EXITED krmkdps [23:18:30.335] elapsed time [00:00:00:00.042]
DBGMISC:         EXITED krmkomp [23:18:30.336] elapsed time [00:00:00:00.285]
DBGPLSQL:        the compiled command tree is: [23:18:30.336] (krmicomp)
DBGPLSQL:          1 CMD type=allocate cmdid=1 status=NOT STARTED
DBGPLSQL:              1 STEPstepid=1 cmdid=1 status=NOT STARTED chid=ORA_DISK_1
DBGPLSQL:                  1 TEXTNOD = --
DBGPLSQL:                  2 TEXTNOD = declare
DBGPLSQL:                  3 TEXTNOD =   devtype       varchar2(255);
DBGPLSQL:                  4 TEXTNOD =   chid          varchar2(255);
DBGPLSQL:                  5 TEXTNOD =   debug         varchar2(10) := null;
DBGPLSQL:                  6 TEXTNOD =   options       number := null;
DBGPLSQL:                  7 TEXTNOD =   node          varchar2(255);
DBGPLSQL:                  8 TEXTNOD =   maxsize       number;
DBGPLSQL:                  9 TEXTNOD =   kbytes        number := null;
DBGPLSQL:                 10 TEXTNOD =   parallel      binary_integer := null;
DBGPLSQL:                 11 TEXTNOD =   readrate      number := null;
DBGPLSQL:                 12 TEXTNOD =   rate          number := null;
DBGPLSQL:                 13 TEXTNOD =   sendcmd       varchar2(256);
DBGPLSQL:                 14 TEXTNOD =   vendor        varchar2(256);
DBGPLSQL:                 15 TEXTNOD =   israc         boolean;
DBGPLSQL:                 16 TEXTNOD =   instname      varchar2(17);
DBGPLSQL:                 17 TEXTNOD =   isfirst       boolean;
DBGPLSQL:                 18 TEXTNOD =   wait          boolean;
DBGPLSQL:                 19 TEXTNOD =   wait_msg_dis  boolean := false;
DBGPLSQL:                 20 TEXTNOD =   num_sbt_chns  number;
DBGPLSQL:                 21 TEXTNOD =   error_str     varchar2(256);
DBGPLSQL:                 22 TEXTNOD =   oam_job_id    varchar2(256);
DBGPLSQL:                 23 TEXTNOD =   request_time  date;
DBGPLSQL:                 24 TEXTNOD =   oam_tst_level number;
DBGPLSQL:                 25 TEXTNOD =   vendortype    number := 0;
DBGPLSQL:                 26 TEXTNOD =   cmdid         varchar2(512);
DBGPLSQL:                 27 TEXTNOD = begin
DBGPLSQL:                 28 TEXTNOD =   
DBGPLSQL:                 29 PRMVAL =  oam_tst_level := 0; chid := 'ORA_DISK_1'; debug := 'MEDIUM';
DBGPLSQL:                 30 TEXTNOD =   if debug is not null then
DBGPLSQL:                 31 TEXTNOD =     krmicd.execSql(
DBGPLSQL:                 32 TEXTNOD =            'alter session set events ''trace[krb.*] disk='
DBGPLSQL:                 33 TEXTNOD =            ||debug|| ', memory=' ||debug||'''');
DBGPLSQL:                 34 TEXTNOD =   end if;
DBGPLSQL:                 35 TEXTNOD =   if options is not null then
DBGPLSQL:                 36 TEXTNOD =     krmicd.execSql(
DBGPLSQL:                 37 TEXTNOD =            'alter session set events ''immediate trace name krb_options level '
DBGPLSQL:                 38 TEXTNOD =            ||options||'''');
DBGPLSQL:                 39 TEXTNOD =   end if;
DBGPLSQL:                 40 TEXTNOD =   devtype := sys.dbms_backup_restore.deviceAllocate( ident => chid,
DBGPLSQL:                 41 TEXTNOD =        node => node, 
DBGPLSQL:                 42 PRMVAL = type=>null,dupcnt=>1
DBGPLSQL:                 43 TEXTNOD =  );
DBGPLSQL:                 44 TEXTNOD =   cmdid := krmicd.getClientInfo;
DBGPLSQL:                 45 TEXTNOD =   if (cmdid is not null) then
DBGPLSQL:                 46 TEXTNOD =      sys.dbms_backup_restore.set_client_info(
DBGPLSQL:                 47 TEXTNOD =        'id='||cmdid||',rman channel='||chid);
DBGPLSQL:                 48 TEXTNOD =   end if;
DBGPLSQL:                 49 TEXTNOD =   if kbytes is null then
DBGPLSQL:                 50 TEXTNOD =      maxsize := sys.dbms_backup_restore.deviceQuery
DBGPLSQL:                 51 TEXTNOD =        (sys.dbms_backup_restore.DEVICEQUERY_MAXSIZE);
DBGPLSQL:                 52 TEXTNOD =   else
DBGPLSQL:                 53 TEXTNOD =      maxsize := kbytes;
DBGPLSQL:                 54 TEXTNOD =   end if;
DBGPLSQL:                 55 TEXTNOD =   if maxsize > 0 then
DBGPLSQL:                 56 TEXTNOD =      sys.dbms_backup_restore.setlimit
DBGPLSQL:                 57 TEXTNOD =        (sys.dbms_backup_restore.kbytes, maxsize);
DBGPLSQL:                 58 TEXTNOD =   end if;
DBGPLSQL:                 59 TEXTNOD =   if devtype = 'SBT_TAPE' then
DBGPLSQL:                 60 TEXTNOD =      vendortype := to_number(sys.dbms_backup_restore.deviceQuery
DBGPLSQL:                 61 TEXTNOD =        (sys.dbms_backup_restore.DEVICEQUERY_VENDORTYPE));
DBGPLSQL:                 62 TEXTNOD =   end if; 
DBGPLSQL:                 63 TEXTNOD =   krmicd.setChannelInfo
DBGPLSQL:                 64 TEXTNOD =     (devtype,
DBGPLSQL:                 65 TEXTNOD =      node,
DBGPLSQL:                 66 TEXTNOD =      maxsize,
DBGPLSQL:                 67 TEXTNOD =      sys.dbms_backup_restore.deviceQuery
DBGPLSQL:                 68 TEXTNOD =        (sys.dbms_backup_restore.DEVICEQUERY_PROXY),
DBGPLSQL:                 69 TEXTNOD =      sys.dbms_backup_restore.deviceQuery
DBGPLSQL:                 70 TEXTNOD =        (sys.dbms_backup_restore.DEVICEQUERY_MAXPROXY), vendortype);
DBGPLSQL:                 71 TEXTNOD =   if parallel is not null then
DBGPLSQL:                 72 TEXTNOD =      sys.dbms_backup_restore.setlimit
DBGPLSQL:                 73 TEXTNOD =        (sys.dbms_backup_restore.parallel, parallel);
DBGPLSQL:                 74 TEXTNOD =   end if;
DBGPLSQL:                 75 TEXTNOD =   if readrate is not null then
DBGPLSQL:                 76 TEXTNOD =      sys.dbms_backup_restore.setlimit
DBGPLSQL:                 77 TEXTNOD =        (sys.dbms_backup_restore.readrate, readrate);
DBGPLSQL:                 78 TEXTNOD =   end if;
DBGPLSQL:                 79 TEXTNOD =   if rate is not null then
DBGPLSQL:                 80 TEXTNOD =      sys.dbms_backup_restore.setlimit
DBGPLSQL:                 81 TEXTNOD =        (sys.dbms_backup_restore.max_read_kbytes, rate);
DBGPLSQL:                 82 TEXTNOD =   end if;
DBGPLSQL:                 83 TEXTNOD =   if sendcmd is not null then
DBGPLSQL:                 84 TEXTNOD =      sys.dbms_backup_restore.devicecommand(sendcmd, NULL);
DBGPLSQL:                 85 TEXTNOD =   end if;
DBGPLSQL:                 86 TEXTNOD =   krmicd.writeMsg(8030, chid);
DBGPLSQL:                 87 TEXTNOD =   krmicd.getInstance(instname, israc);
DBGPLSQL:                 88 TEXTNOD =   if (israc) then
DBGPLSQL:                 89 TEXTNOD =      krmicd.writeMsg(8605, chid, to_char(krmicd.getSid),
DBGPLSQL:                 90 TEXTNOD =                      to_char(instname), devtype);
DBGPLSQL:                 91 TEXTNOD =   else
DBGPLSQL:                 92 TEXTNOD =      krmicd.writeMsg(8500, chid, to_char(krmicd.getSid), devtype);
DBGPLSQL:                 93 TEXTNOD =   end if;
DBGPLSQL:                 94 TEXTNOD =   vendor := sys.dbms_backup_restore.deviceQuery
DBGPLSQL:                 95 TEXTNOD =     (sys.dbms_backup_restore.DEVICEQUERY_VENDOR);
DBGPLSQL:                 96 TEXTNOD =   if vendor is not null then
DBGPLSQL:                 97 TEXTNOD =      krmicd.writemsg(8526, chid, vendor);
DBGPLSQL:                 98 TEXTNOD =   end if;
DBGPLSQL:                 99 TEXTNOD =   if (oam_tst_level > 0 and
DBGPLSQL:                100 TEXTNOD =       (vendortype = sys.dbms_backup_restore.DEVICEQUERY_BA) ) then
DBGPLSQL:                101 TEXTNOD = --
DBGPLSQL:                102 TEXTNOD =     sys.dbms_backup_restore.setParms(p0 => 14,
DBGPLSQL:                103 TEXTNOD =                                      p1 => 1);
DBGPLSQL:                104 TEXTNOD =   end if;
DBGPLSQL:                105 TEXTNOD =  
DBGPLSQL:                106 TEXTNOD =  
DBGPLSQL:                107 TEXTNOD = --
DBGPLSQL:                108 TEXTNOD = --
DBGPLSQL:                109 TEXTNOD =   if (vendortype = sys.dbms_backup_restore.DEVICEQUERY_BA) then
DBGPLSQL:                110 TEXTNOD =      krmicd.writeMsg(6918);
DBGPLSQL:                111 TEXTNOD =   end if;
DBGPLSQL:                112 TEXTNOD =  
DBGPLSQL:                113 TEXTNOD = end;
DBGMISC:        EXITED krmicomp with address 40451008 [23:18:30.392] elapsed time [00:00:00:00.342]
DBGMISC:        ENTERED krmiexe [23:18:30.392]
DBGMISC:         Executing command allocate [23:18:30.393] (krmiexe)
DBGRPC:          krmxr - entering
DBGRPC:          krmxpoq - returning rpc_number: 2 with status: FINISHED178 for channel default
DBGRPC:          krmxr - channel default has rpc_count: 2
DBGRPC:          ENTERED krmqgns
DBGRPC:           krmqgns: looking for work for channel default (krmqgns)
DBGRPC:           krmqgns: commands remaining to be executed: (krmqgns)
DBGRPC:           CMD type=allocate cmdid=1 status=NOT STARTED
DBGRPC:                 1 STEPstepid=1 cmdid=1 status=NOT STARTED chid=ORA_DISK_1
DBGRPC:           krmxcc - entering
DBGRPC:           krmxcc - creating context for channel No-chid
DBGMISC:          ENTERED krmksimronly [23:18:30.513]
DBGMISC:          EXITED krmksimronly [23:18:30.513] elapsed time [00:00:00:00.000]

DBGSQL:           CHANNEL> select sys_context('userenv', 'con_id'), sys_context('userenv', 'cdb_name'), sys_context('userenv', 'con_name'), case when sys_context('userenv', 'is_application_root') = 'YES' then 1 else 0 end into :pdbid, :cdbname, :pdbname, :approot from dual
DBGSQL:              sqlcode = 0
DBGSQL:               D :pdbid = 1
DBGSQL:               D :cdbname = TRMAN01
DBGSQL:               D :pdbname = CDB$ROOT
DBGSQL:               D :approot = 0

DBGSQL:           CHANNEL> select decode(upper(value), 'TRUE', 1, 0)   into :parmvalue   from v$parameter  where lower(name) = '_pdb_name_case_sensitive'
DBGSQL:              sqlcode = 1403
DBGRPC:           krmxcc - seting up for out-of-band
DBGRPC:           krmxpos - setting up channel No-chid
DBGRPC:           krmxpos - channel No-chid attached to target polling channel
DBGRPC:           krmxcc - using default sga_heap_size of 16777216
DBGRPC:           krmxcc - created context for channel No-chid
DBGMISC:          krmqopen: opening new channel context for channel ORA_DISK_1, instid 1 [23:18:30.564]
DBGRPC:           krmxcr - channel ORA_DISK_1 resetted
DBGRPC:           krmqgns: no work found for channel default (krmqgns)
DBGRPC:            (krmqgns)
DBGRPC:          EXITED krmqgns with status 1
DBGRPC:          ENTERED krmqgns
DBGRPC:           krmqgns: looking for work for channel ORA_DISK_1 (krmqgns)
DBGRPC:           krmqgns: commands remaining to be executed: (krmqgns)
DBGRPC:           CMD type=allocate cmdid=1 status=NOT STARTED
DBGRPC:                 1 STEPstepid=1 cmdid=1 status=NOT STARTED chid=ORA_DISK_1
DBGRPC:           krmqgns: channel ORA_DISK_1 assigned step 1 (krmqgns)
DBGRPC:            (krmqgns)
DBGRPC:          EXITED krmqgns with status 0
DBGRPC:          krmxcis - channel ORA_DISK_1, calling pcicmp
DBGRPC:          krmxr - channel ORA_DISK_1 calling peicnt
DBGRPC:          krmxrpc - channel ORA_DISK_1 kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.DEVICEALLOCATE excl: 0
DBGRPC:          krmxrpc - channel ORA_DISK_1 kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.DEVICEQUERY excl: 0
DBGRPC:          krmxrpc - channel ORA_DISK_1 kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.DEVICEQUERY excl: 0
DBGRPC:          krmxrpc - channel ORA_DISK_1 kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.DEVICEQUERY excl: 0
DBGMISC:         ENTERED krmzlog [23:18:30.648]
RMAN-08030: allocated channel: ORA_DISK_1
DBGMISC:         EXITED krmzlog [23:18:30.652] elapsed time [00:00:00:00.004]
DBGMISC:         ENTERED krmzlog [23:18:30.661]
RMAN-08500: channel ORA_DISK_1: SID=144 device type=DISK
DBGMISC:         EXITED krmzlog [23:18:30.665] elapsed time [00:00:00:00.004]
DBGRPC:          krmxrpc - channel ORA_DISK_1 kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.DEVICEQUERY excl: 0
DBGRPC:          krmxr - channel ORA_DISK_1 returned from peicnt
DBGRPC:          krmxr - channel ORA_DISK_1 finished step
DBGRPC:                ENTERED krmqgns
krmqgns: looking for work for channel default (krmqgns)
DBGRPC:           krmqgns: commands remaining to be executed: (krmqgns)
DBGRPC:           CMD type=allocate cmdid=1 status=STARTED
DBGRPC:                 1 STEPstepid=1 cmdid=1 status=FINISHED chid=ORA_DISK_1
DBGRPC:           krmqgns: no work found for channel default (krmqgns)
DBGRPC:            (krmqgns)
DBGRPC:          EXITED krmqgns with status 1
DBGRPC:          ENTERED krmqgns
DBGRPC:           krmqgns: channel ORA_DISK_1 finished step 1 (krmqgns)
DBGRPC:           krmqgns: looking for work for channel ORA_DISK_1 (krmqgns)
DBGRPC:           krmqgns: commands remaining to be executed: (krmqgns)
DBGRPC:           krmqgns: no work found for channel ORA_DISK_1 (krmqgns)
DBGRPC:            (krmqgns)
DBGRPC:          EXITED krmqgns with status 1
DBGRPC:          ENTERED krmqgns
DBGRPC:           krmqgns: looking for work for channel default (krmqgns)
DBGRPC:           krmqgns: commands remaining to be executed: (krmqgns)
DBGRPC:           krmqgns: no work found for channel default (krmqgns)
DBGRPC:            (krmqgns)
DBGRPC:          EXITED krmqgns with status 1
DBGRPC:          ENTERED krmqgns
DBGRPC:           krmqgns: looking for work for channel ORA_DISK_1 (krmqgns)
DBGRPC:           krmqgns: commands remaining to be executed: (krmqgns)
DBGRPC:           krmqgns: no work found for channel ORA_DISK_1 (krmqgns)
DBGRPC:            (krmqgns)
DBGRPC:          EXITED krmqgns with status 1
DBGRPC:          krmxr - all done
DBGRPC:          krmxr - exiting with 0
DBGMISC:        EXITED krmiexe with status 0 [23:18:30.684] elapsed time [00:00:00:00.292]
DBGMISC:        Finished allocate at 26-FEB-2020 23:18:30 [23:18:30.685]
DBGMISC:       EXITED krmice [23:18:30.851] elapsed time [00:00:00:00.803]
DBGMISC:       krmqalc1() : Exit [23:18:30.851]
DBGMISC:       ENTERED krmkcrsr [23:18:30.852]
DBGMISC:        pending krmkcrsr iterations now called  [23:18:30.852] (krmkcrsr)
DBGMISC:        ENTERED krmkcrsr [23:18:30.853]
DBGMISC:         channel ORA_DISK_1, device type allocated DISK: [23:18:30.853] (krmkcrsr)

DBGSQL:          TARGET> begin sys.dbms_backup_restore.createRmanStatusRow( level        => :level, parent_id    => :pid, parent_stamp => :pts, status       => :status, command_id   => :command_id, operation    => :operation, row_id       => :row_id, row_stamp    => :row_stamp, flags        => :flags); end;
DBGSQL:             sqlcode = 0
DBGSQL:              B :row_id = 539
DBGSQL:              B :row_stamp = 1033427910
DBGSQL:              B :level = 1
DBGSQL:              B :pid = 538
DBGSQL:              B :pts = 1033427908
DBGSQL:              B :status = 1
DBGSQL:              B :command_id = 2020-02-26T23:18:26
DBGSQL:              B :operation = recover PLUGGABLE DATABASE
DBGSQL:              B :flags = 1026
DBGMISC:        EXITED krmkcrsr [23:18:30.873] elapsed time [00:00:00:00.019]
DBGTSPITR:      ENTERED krmrBuildAuxiliarySet
DBGTSPITR:       Until scn:  (krmrBuildAuxiliarySet)
DBGDUP:          ENTERED krmkgatl
DBGRCV:           ENTERED krmkicat
DBGRCV:            host=TARGET, transclause: 1, needuntscn: 1 haveuntscn: 0 (krmkicat)
DBGRCV:            Need to initialize target (krmkicat)
DBGRCV:            Need to initialize rcvcat (krmkicat)
DBGRCV:            Need to set new until clause (krmkicat)

DBGSQL:            TARGET> declare transclause boolean := FALSE; begin if (:transclause > 0) then transclause := TRUE; end if; dbms_rcvman.resetAll(transclause => transclause); end; 
DBGSQL:               sqlcode = 0
DBGSQL:                B :transclause = 1
       DBGRCVMAN: resetAll
       DBGRCVMAN: ENTERING setRAflags
       DBGRCVMAN: setRAflags kindMask=255 containerMask=15 actionMask=63
       DBGRCVMAN:  ENTERING setComputeRecoveryActionMasks816
       DBGRCVMAN:   ENTERING setComputeRecoveryActionMasks
       DBGRCVMAN:   EXITING setComputeRecoveryActionMasks
       DBGRCVMAN:  EXITING setComputeRecoveryActionMasks816
       DBGRCVMAN: EXITING setRAflags
       DBGRCVMAN: allIncarnations is set to FALSE
       DBGRCVMAN: getRA_likePattern=
       DBGRCVMAN: restoreTag=,tag_like=0
       DBGRCVMAN: this_cftype=CURRENT
       DBGRCVMAN: this_dbrole=PRIMARY
       DBGRCVMAN: reset transclause
       DBGRCVMAN: *****BsRecCache Statistics*****
       DBGRCVMAN: Cache size=0 hit=0
       DBGRCVMAN: rcvRecBackupAge= 0
       DBGRCVMAN: thisBackupAge= 0
       DBGRCVMAN: ENTERING setRedoLogDeletionPolicy
       DBGRCVMAN:    setRedoLogDeletionPolicy with policy = TO NONE
       DBGRCVMAN:    setRedoLogDeletionPolicy with alldest = 0
       DBGRCVMAN: redoLogDeletionPolicyDefValid = 1
       DBGRCVMAN:  ENTERING validateStandbyConfig1
       DBGRCVMAN: policy  = TO NONE
       DBGRCVMAN: alldest = 0
       DBGRCVMAN:  EXITING validateStandbyConfig1 with status   = 1
       DBGRCVMAN: EXITING setRedoLogDeletionPolicy with policy = TO NONE with alldest = 0
DBGRCV:            Until time: to_date('26.02.2020 23:17:23','DD.MM.YYYY HH24:MI:SS'), toscn: 0 (krmkicat)

DBGSQL:            TARGET> select to_date('26.02.2020 23:17:23','DD.MM.YYYY HH24:MI:SS') from sys.dual
DBGSQL:               sqlcode = 0
DBGSQL:                D :mydate = "26-FEB-2020 23:17:23"

DBGSQL:            TARGET> begin    dbms_rcvman.setAllIncarnations(TRUE); end; 
DBGSQL:               sqlcode = 0
       DBGRCVMAN: allIncarnations is set to TRUE

DBGSQL:            TARGET> declare    tmpscn number; begin    dbms_rcvman.setUntilTime(:date);    tmpscn := dbms_rcvman.getUntilScn;    if (:toscn > 0) then       dbms_rcvman.setUntilScn(tmpscn + 1);    end if;    :untscn := tmpscn; end; 
DBGSQL:               sqlcode = 0
DBGSQL:                B :toscn = NULL
DBGSQL:                B :untscn = 2376934
DBGSQL:                B :date = "26-FEB-2020 23:17:23"
       DBGRCVMAN: ENTERING setUntilTime
       DBGRCVMAN: EXITING setUntilTime untilSCN=2376934
DBGANY:            Current untilscn: 2376934 [23:18:31.089] (krmkicat)
DBGRCV:           EXITED krmkicat

DBGSQL:           TARGET> begin dbms_rcvman.listRollbackSegTableSpace; end; 
DBGSQL:              sqlcode = 0
      DBGRCVMAN: ENTERING listRollbackSegTableSpace
      DBGRCVMAN:  OPENING cursor lrtbs in listRollbackSegTableSpace
      DBGRCVMAN: EXITING listRollbackSegTableSpace

DBGSQL:           TARGET> begin :got_one := dbms_rcvman.listGetTableSpace    (:tsno, :tsnam, :pdbname); end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :got_one = 1
DBGSQL:               B :tsno = 0
DBGSQL:               B :tsnam = SYSTEM
DBGSQL:               B :pdbname = CDB$ROOT
      DBGRCVMAN: ENTERING listGetTableSpace
      DBGRCVMAN: EXITING listGetTableSpace with: TRUE#

DBGSQL:           TARGET> begin :got_one := dbms_rcvman.listGetTableSpace    (:tsno, :tsnam, :pdbname); end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :got_one = 1
DBGSQL:               B :tsno = 0
DBGSQL:               B :tsnam = SYSTEM
DBGSQL:               B :pdbname = TSPITR
      DBGRCVMAN: ENTERING listGetTableSpace
      DBGRCVMAN: EXITING listGetTableSpace with: TRUE#

DBGSQL:           TARGET> begin :got_one := dbms_rcvman.listGetTableSpace    (:tsno, :tsnam, :pdbname); end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :got_one = 1
DBGSQL:               B :tsno = 2
DBGSQL:               B :tsnam = UNDOTBS1
DBGSQL:               B :pdbname = CDB$ROOT
      DBGRCVMAN: ENTERING listGetTableSpace
      DBGRCVMAN: EXITING listGetTableSpace with: TRUE#

DBGSQL:           TARGET> begin :got_one := dbms_rcvman.listGetTableSpace    (:tsno, :tsnam, :pdbname); end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :got_one = 1
DBGSQL:               B :tsno = 2
DBGSQL:               B :tsnam = UNDOTBS1
DBGSQL:               B :pdbname = TSPITR
      DBGRCVMAN: ENTERING listGetTableSpace
      DBGRCVMAN: EXITING listGetTableSpace with: TRUE#

DBGSQL:           TARGET> begin :got_one := dbms_rcvman.listGetTableSpace    (:tsno, :tsnam, :pdbname); end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :got_one = 0
DBGSQL:               B :tsno = NULL
DBGSQL:               B :tsnam = NULL
DBGSQL:               B :pdbname = NULL
      DBGRCVMAN: ENTERING listGetTableSpace
      DBGRCVMAN: EXITING listGetTableSpace with: FALSE#
DBGDUP:           List of tablespaces returned (krmkgatl)
DBGDUP:           TSLIST
DBGDUP:             1 TSSPEC
DBGDUP:                 1 TSNAMEQ = SYSTEM
DBGDUP:             2 TSSPEC
DBGDUP:                 1 PDBNAME = TSPITR
DBGDUP:                 2 TSNAMEQ = SYSTEM
DBGDUP:             3 TSSPEC
DBGDUP:                 1 TSNAMEQ = UNDOTBS1
DBGDUP:             4 TSSPEC
DBGDUP:                 1 PDBNAME = TSPITR
DBGDUP:                 2 TSNAMEQ = UNDOTBS1
DBGDUP:          EXITED krmkgatl with address 40444200
RMAN-05026: warning: presuming following set of tablespaces applies to specified point-in-time
DBGMISC:         ENTERED krmkursr [23:18:31.327]

DBGSQL:           TARGET> begin sys.dbms_backup_restore.updateRmanStatusRow( row_id    => :row_id, row_stamp => :row_stamp, status    => :status); end;
DBGSQL:              sqlcode = 0
DBGSQL:               B :row_id = 539
DBGSQL:               B :row_stamp = 1033427910
DBGSQL:               B :status = 9
DBGMISC:         EXITED krmkursr [23:18:31.334] elapsed time [00:00:00:00.007]
RMAN-05027: 
List of tablespaces expected to have UNDO segments
RMAN-05028: Tablespace SYSTEM
RMAN-05028: Tablespace TSPITR:SYSTEM
RMAN-05028: Tablespace UNDOTBS1
RMAN-05028: Tablespace TSPITR:UNDOTBS1

DBGSQL:          TARGET> select count(*) into :dbstate from v$tablespace ts where lower(ts.name) = 'sysext' and (ts.con_id = :pdbid_in or ts.con_id = 0)
DBGSQL:             sqlcode = 0
DBGSQL:              D :dbstate = 0
DBGSQL:              B :pdbid_in = 1

DBGSQL:          TARGET> select count(*) into :dbstate from v$tablespace ts where lower(ts.name) = 'sysext' and (ts.con_id = :pdbid_in or ts.con_id = 0)
DBGSQL:             sqlcode = 0
DBGSQL:              D :dbstate = 0
DBGSQL:              B :pdbid_in = 6
DBGTSPITR:         1 TSLIST
DBGTSPITR:             1 TSSPEC
DBGTSPITR:                 1 TSNAMEQ = SYSTEM
DBGTSPITR:             2 TSSPEC
DBGTSPITR:                 1 PDBNAME = TSPITR
DBGTSPITR:                 2 TSNAMEQ = SYSTEM
DBGTSPITR:             3 TSSPEC
DBGTSPITR:                 1 TSNAMEQ = UNDOTBS1
DBGTSPITR:             4 TSSPEC
DBGTSPITR:                 1 PDBNAME = TSPITR
DBGTSPITR:                 2 TSNAMEQ = UNDOTBS1
DBGTSPITR:             5 TSSPEC
DBGTSPITR:                 1 TSNAMEQ = SYSAUX
DBGTSPITR:             6 TSSPEC
DBGTSPITR:                 1 PDBNAME = TSPITR
DBGTSPITR:                 2 TSNAMEQ = SYSAUX
DBGTSPITR:      EXITED krmrBuildAuxiliarySet
DBGTSPITR:      ENTERED krmrCheckAuxiliaryInstance
DBGTSPITR:       krmrpit - Starting automatic auxiliary instance      ENTERED krmkcaux
ORACLE_SID: lzww (krmkcaux)
RMAN-06220: 
Creating automatic instance, with SID='lzww'

DBGSQL:           TARGET> begin sys.dbms_backup_restore.manageAuxInstance(:lorasid, :lclean); end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :lorasid = lzww
DBGSQL:               B :lclean = 0

DBGSQL:           TARGET> select value into :parmvalue from v$parameter where name = 'max_string_size' 
DBGSQL:              sqlcode = 0
DBGSQL:               D :parmvalue = STANDARD

DBGSQL:           TARGET> select to_char(ceil(to_number(value) / 1024 / 1024)), ceil(to_number(value) / 1024 / 1024) into :txtparmvalue, :parmvalue from v$parameter where lower(name) = 'db_2k_cache_size'
DBGSQL:              sqlcode = 0
DBGSQL:               D :txtparmvalue = 0
DBGSQL:               D :parmvalue = 0

DBGSQL:           TARGET> select to_char(ceil(to_number(value) / 1024 / 1024)), ceil(to_number(value) / 1024 / 1024) into :txtparmvalue, :parmvalue from v$parameter where lower(name) = 'db_4k_cache_size'
DBGSQL:              sqlcode = 0
DBGSQL:               D :txtparmvalue = 0
DBGSQL:               D :parmvalue = 0

DBGSQL:           TARGET> select to_char(ceil(to_number(value) / 1024 / 1024)), ceil(to_number(value) / 1024 / 1024) into :txtparmvalue, :parmvalue from v$parameter where lower(name) = 'db_8k_cache_size'
DBGSQL:              sqlcode = 0
DBGSQL:               D :txtparmvalue = 0
DBGSQL:               D :parmvalue = 0

DBGSQL:           TARGET> select to_char(ceil(to_number(value) / 1024 / 1024)), ceil(to_number(value) / 1024 / 1024) into :txtparmvalue, :parmvalue from v$parameter where lower(name) = 'db_16k_cache_size'
DBGSQL:              sqlcode = 0
DBGSQL:               D :txtparmvalue = 0
DBGSQL:               D :parmvalue = 0

DBGSQL:           TARGET> select to_char(ceil(to_number(value) / 1024 / 1024)), ceil(to_number(value) / 1024 / 1024) into :txtparmvalue, :parmvalue from v$parameter where lower(name) = 'db_32k_cache_size'
DBGSQL:              sqlcode = 0
DBGSQL:               D :txtparmvalue = 0
DBGSQL:               D :parmvalue = 0

DBGSQL:           TARGET> select value, to_number(value) into :txtparmvalue, :parmvalue from v$parameter where lower(name) = 'processes'
DBGSQL:              sqlcode = 0
DBGSQL:               D :txtparmvalue = 300
DBGSQL:               D :parmvalue = 300

DBGSQL:           TARGET> select to_char(ceil(sum(value) / 1024 / 1024)), ceil(sum(value) / 1024 / 1024) into :txtparmvalue, :parmvalue from v$sga 
DBGSQL:              sqlcode = 0
DBGSQL:               D :txtparmvalue = 768
DBGSQL:               D :parmvalue = 768

DBGSQL:           TARGET> select value, to_number(value) into :txtparmvalue, :parmvalue from v$parameter where lower(name) = 'db_block_size'
DBGSQL:              sqlcode = 0
DBGSQL:               D :txtparmvalue = 8192
DBGSQL:               D :parmvalue = 8192

DBGSQL:           TARGET> select value, to_number(value) into :txtparmvalue, :parmvalue from v$parameter where lower(name) = 'db_files'
DBGSQL:              sqlcode = 0
DBGSQL:               D :txtparmvalue = 200
DBGSQL:               D :parmvalue = 200

DBGSQL:           TARGET> select value into :parmvalue from v$parameter where name = 'diagnostic_dest' 
DBGSQL:              sqlcode = 0
DBGSQL:               D :parmvalue = /u00/app/oracle

DBGSQL:           TARGET> select value into :parmvalue from v$parameter where name = 'db_domain' 
DBGSQL:              sqlcode = 0
DBGSQL:               D :parmvalue = NULL

DBGSQL:           TARGET> select decode(value, '0', 0, 1) into :dbstate from v$parameter where name = 'db_2k_cache_size' and value is not null
DBGSQL:              sqlcode = 0
DBGSQL:               D :dbstate = 0

DBGSQL:           TARGET> select decode(value, '0', 0, 1) into :dbstate from v$parameter where name = 'db_4k_cache_size' and value is not null
DBGSQL:              sqlcode = 0
DBGSQL:               D :dbstate = 0

DBGSQL:           TARGET> select decode(value, '0', 0, 1) into :dbstate from v$parameter where name = 'db_8k_cache_size' and value is not null
DBGSQL:              sqlcode = 0
DBGSQL:               D :dbstate = 0

DBGSQL:           TARGET> select decode(value, '0', 0, 1) into :dbstate from v$parameter where name = 'db_16k_cache_size' and value is not null
DBGSQL:              sqlcode = 0
DBGSQL:               D :dbstate = 0

DBGSQL:           TARGET> select decode(value, '0', 0, 1) into :dbstate from v$parameter where name = 'db_32k_cache_size' and value is not null
DBGSQL:              sqlcode = 0
DBGSQL:               D :dbstate = 0

DBGSQL:           TARGET> select decode(value, '0', 0, 1) into :dbstate from v$parameter where name = 'processes' and value is not null
DBGSQL:              sqlcode = 0
DBGSQL:               D :dbstate = 1
RMAN-04031: 
initialization parameters used for automatic instance:
db_name=TRMAN01
db_unique_name=lzww_pitr_TSPITR_TRMAN01
compatible=19.0.0
db_block_size=8192
db_files=200
diagnostic_dest=/u00/app/oracle
_system_trig_enabled=FALSE
sga_target=768M
processes=200
#No auxiliary destination in use
enable_pluggable_database=true
_clone_one_pdb_recovery=true
#No auxiliary parameter file used


DBGANY:           Parameter File name: /tmp/ora_tfilxKVyt3 [23:18:31.763] (krmkcaux)
DBGMISC:          START
DBGMISC:            1 CLOKW
DBGMISC:            2 PFILE
DBGMISC:                1 TEXTNOD = /tmp/ora_tfilxKVyt3
DBGMISC:            3 NOMOUNT
DBGMISC:            4 FORCE
RMAN-06223: starting up automatic instance TRMAN01


DBGSQL:           TARGET> begin sys.dbms_backup_restore.getCnctStr( cnctstr  => :lcnctstr, orasid   => :lorasid, escaped  => FALSE, passauth => TRUE); end;
DBGSQL:              sqlcode = 0
DBGSQL:               B :lcnctstr = (DESCRIPTION=(ADDRESS=(PROTOCOL=beq)(PROGRAM=/u00/app/oracle/product/19.0.0.0/bin/oracle)(ARGV0=oraclelzww)(ARGS='(DESCRIPTION=(LOCAL=YES)(ADDRESS=(PROTOCOL=beq)))')(ENVS='ORACLE_SID=lzww'))(CONNECT_DATA=(SID=lzww)))
DBGSQL:               B :lorasid = lzww
DBGMISC:          krmqacen() [23:18:31.781]
DBGMISC:          krmqacen() : Exit [23:18:31.781]
RMAN-06196: Oracle instance started

DBGSQL:           TARGET> select decode(status, 'OPEN', 1, 0), decode(archiver, 'FAILED', 1, 0), decode(database_status, 'SUSPENDED', 1, 0) into :status, :archstuck, :dbsuspended from v$instance
DBGSQL:              sqlcode = 0
DBGSQL:               D :status = 1
DBGSQL:               D :archstuck = 0
DBGSQL:               D :dbsuspended = 0

DBGSQL:           TARGET> select decode(open_mode, 'READ WRITE', 1, 0) into :read_write from v$database
DBGSQL:              sqlcode = 0
DBGSQL:               D :read_write = 1

DBGSQL:           TARGET> select value into :vcomp_txt from  v$parameter where name = 'compatible'
DBGSQL:              sqlcode = 0
DBGSQL:               D :vcomp_txt = 19.0.0

DBGSQL:           TARGET> declare dot1st number; dot2nd number; dot3rd number; comptxt varchar2(255) := :vcomp_txt; begin comptxt := comptxt || '.0.0'; dot1st := instr(comptxt, '.', 1, 1); dot2nd := instr(comptxt, '.', 1, 2); dot3rd := instr(comptxt, '.', 1, 3); comptxt :=  lpad(substr(comptxt, 1, dot1st - 1), 2, '0') || lpad(substr(comptxt, dot1st + 1, dot2nd - dot1st - 1), 2, '0')  || lpad(substr(comptxt, dot2nd + 1, dot3rd - dot2nd - 1), 2, '0');:vcomp_ub4 := to_number(comptxt); end;
DBGSQL:              sqlcode = 0
DBGSQL:               B :vcomp_ub4 = 190000
DBGSQL:               B :vcomp_txt = 19.0.0
DBGMISC:          krmkpdbs(): vcomp_txt:19.0.0 vcomp_ub4:190000 flags:5 [23:18:54.636]
DBGMISC:          krmqacen() [23:18:54.638]
DBGMISC:          krmqacen() : Exit [23:18:54.638]

DBGSQL:           CHANNEL> select sys_context('userenv', 'con_id'), sys_context('userenv', 'cdb_name'), sys_context('userenv', 'con_name'), case when sys_context('userenv', 'is_application_root') = 'YES' then 1 else 0 end into :pdbid, :cdbname, :pdbname, :approot from dual
DBGSQL:              sqlcode = 0
DBGSQL:               D :pdbid = 1
DBGSQL:               D :cdbname = TRMAN01
DBGSQL:               D :pdbname = CDB$ROOT
DBGSQL:               D :approot = 0

DBGSQL:           CHANNEL> select decode(upper(value), 'TRUE', 1, 0)   into :parmvalue   from v$parameter  where lower(name) = '_pdb_name_case_sensitive'
DBGSQL:              sqlcode = 1403

DBGSQL:           CHANNEL> select sys_context('userenv', 'con_id'), sys_context('userenv', 'cdb_name'), sys_context('userenv', 'con_name'), case when sys_context('userenv', 'is_application_root') = 'YES' then 1 else 0 end into :pdbid, :cdbname, :pdbname, :approot from dual
DBGSQL:              sqlcode = 0
DBGSQL:               D :pdbid = 1
DBGSQL:               D :cdbname = TRMAN01
DBGSQL:               D :pdbname = CDB$ROOT
DBGSQL:               D :approot = 0

DBGSQL:           CHANNEL> select decode(upper(value), 'TRUE', 1, 0)   into :parmvalue   from v$parameter  where lower(name) = '_pdb_name_case_sensitive'
DBGSQL:              sqlcode = 1403
DBGRPC:           krmxcc - entering
DBGRPC:           krmxcc - creating context for channel No-chid
DBGRPC:           krmxcc - connecting using clone default channel
DBGRPC:           krmxcc - seting up for out-of-band
DBGRPC:           krmxpos - setting up channel No-chid
DBGRPC:           krmxpos - creating polling channel for channel No-chid

DBGSQL:           CHANNEL> select sys_context('userenv', 'con_id'), sys_context('userenv', 'cdb_name'), sys_context('userenv', 'con_name'), case when sys_context('userenv', 'is_application_root') = 'YES' then 1 else 0 end into :pdbid, :cdbname, :pdbname, :approot from dual
DBGSQL:              sqlcode = 0
DBGSQL:               D :pdbid = 1
DBGSQL:               D :cdbname = TRMAN01
DBGSQL:               D :pdbname = CDB$ROOT
DBGSQL:               D :approot = 0

DBGSQL:           CHANNEL> select decode(upper(value), 'TRUE', 1, 0)   into :parmvalue   from v$parameter  where lower(name) = '_pdb_name_case_sensitive'
DBGSQL:              sqlcode = 1403
DBGRPC:           krmxpos - channel No-chid polling channel created to instance 1
DBGRPC:           krmxcc - using default sga_heap_size of 16777216
DBGRPC:           krmxcc - created context for channel No-chid
DBGMISC:          krmqopen: opening new channel context for channel clone_default, instid 1 [23:18:56.042]
DBGRPC:           krmxcr - channel clone_default resetted
DBGSQL:           ENTERED krmkosqlerr

DBGSQL:            AUXILIARY> select decode(open_mode, 'MOUNTED', 0, 'READ WRITE', 1, 'READ ONLY', 1, 'READ ONLY WITH APPLY', 1, 0) into :isdbopen from v$database
DBGSQL:               sqlcode = 1507
DBGSQL:            error: ORA-01507: database not mounted (krmkosqlerr)
DBGSQL:             (krmkosqlerr)
DBGSQL:           EXITED krmkosqlerr

DBGSQL:           AUXILIARY> select decode(status, 'OPEN', 1, 0), decode(archiver, 'FAILED', 1, 0), decode(database_status, 'SUSPENDED', 1, 0) into :status, :archstuck, :dbsuspended from v$instance
DBGSQL:              sqlcode = 0
DBGSQL:               D :status = 0
DBGSQL:               D :archstuck = 0
DBGSQL:               D :dbsuspended = 0

DBGSQL:           AUXILIARY> select value into :vcomp_txt from  v$parameter where name = 'compatible'
DBGSQL:              sqlcode = 0
DBGSQL:               D :vcomp_txt = 19.0.0

DBGSQL:           AUXILIARY> declare dot1st number; dot2nd number; dot3rd number; comptxt varchar2(255) := :vcomp_txt; begin comptxt := comptxt || '.0.0'; dot1st := instr(comptxt, '.', 1, 1); dot2nd := instr(comptxt, '.', 1, 2); dot3rd := instr(comptxt, '.', 1, 3); comptxt :=  lpad(substr(comptxt, 1, dot1st - 1), 2, '0') || lpad(substr(comptxt, dot1st + 1, dot2nd - dot1st - 1), 2, '0')  || lpad(substr(comptxt, dot2nd + 1, dot3rd - dot2nd - 1), 2, '0');:vcomp_ub4 := to_number(comptxt); end;
DBGSQL:              sqlcode = 0
DBGSQL:               B :vcomp_ub4 = 190000
DBGSQL:               B :vcomp_txt = 19.0.0
DBGMISC:          krmkpdbs(): vcomp_txt:19.0.0 vcomp_ub4:190000 flags:0 [23:18:56.243]

DBGSQL:           AUXILIARY> begin :vsn_min := dbms_backup_restore.protocol_version_number_min; :rel_min := dbms_backup_restore.protocol_release_number_min; :upd_min := dbms_backup_restore.protocol_update_number_min; :cmp_min := 0; :vsn_max := dbms_backup_restore.protocol_version_number_max; :rel_max := dbms_backup_restore.protocol_release_number_max; :upd_max := dbms_backup_restore.protocol_update_number_max; :cmp_max := 0; :pkg_vsn := to_char(:vsn_max, 'fm00')||'.'|| to_char(:rel_max, 'fm00')||'.'|| to_char(:upd_max, 'fm00')||'.'|| to_char(:cmp_max, 'fm00'); end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :vsn_min = 8
DBGSQL:               B :rel_min = 0
DBGSQL:               B :upd_min = 4
DBGSQL:               B :cmp_min = 0
DBGSQL:               B :vsn_max = 19
DBGSQL:               B :rel_max = 5
DBGSQL:               B :upd_max = 0
DBGSQL:               B :cmp_max = 0
DBGSQL:               B :pkg_vsn = 19.05.00.00

DBGSQL:           AUXILIARY> begin :cmp_min := dbms_backup_restore.protocol_component_number_min; :cmp_max := dbms_backup_restore.protocol_component_number_max; :pkg_vsn := to_char(:vsn_max, 'fm00')||'.'|| to_char(:rel_max, 'fm00')||'.'|| to_char(:upd_max, 'fm00')||'.'|| to_char(:cmp_max, 'fm00'); end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :cmp_min = 0
DBGSQL:               B :cmp_max = 0
DBGSQL:               B :pkg_vsn = 19.05.00.00
DBGSQL:               B :vsn_max = 19
DBGSQL:               B :rel_max = 5
DBGSQL:               B :upd_max = 0
DBGSQL:               B :cmp_max = 0

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 08.00.04.00
DBGSQL:               B :pkg_vsnub4 = 8000400

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 08.00.05.00
DBGSQL:               B :pkg_vsnub4 = 8000500

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 08.01.03.00
DBGSQL:               B :pkg_vsnub4 = 8010300

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 08.01.05.00
DBGSQL:               B :pkg_vsnub4 = 8010500

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 08.01.06.00
DBGSQL:               B :pkg_vsnub4 = 8010600

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 08.01.07.00
DBGSQL:               B :pkg_vsnub4 = 8010700

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 09.00.00.00
DBGSQL:               B :pkg_vsnub4 = 9000000

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 09.02.00.00
DBGSQL:               B :pkg_vsnub4 = 9020000

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 10.01.00.00
DBGSQL:               B :pkg_vsnub4 = 10010000

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 10.02.00.00
DBGSQL:               B :pkg_vsnub4 = 10020000

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 10.02.00.01
DBGSQL:               B :pkg_vsnub4 = 10020001

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 11.01.00.00
DBGSQL:               B :pkg_vsnub4 = 11010000

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 11.01.00.01
DBGSQL:               B :pkg_vsnub4 = 11010001

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 11.01.00.02
DBGSQL:               B :pkg_vsnub4 = 11010002

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 11.01.00.03
DBGSQL:               B :pkg_vsnub4 = 11010003

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 11.01.00.04
DBGSQL:               B :pkg_vsnub4 = 11010004

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 11.01.00.05
DBGSQL:               B :pkg_vsnub4 = 11010005

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 11.01.00.06
DBGSQL:               B :pkg_vsnub4 = 11010006

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 11.01.00.07
DBGSQL:               B :pkg_vsnub4 = 11010007

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 11.02.00.00
DBGSQL:               B :pkg_vsnub4 = 11020000

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 11.02.00.01
DBGSQL:               B :pkg_vsnub4 = 11020001

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 11.02.00.02
DBGSQL:               B :pkg_vsnub4 = 11020002

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 12.01.00.00
DBGSQL:               B :pkg_vsnub4 = 12010000

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 12.01.00.01
DBGSQL:               B :pkg_vsnub4 = 12010001

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 12.01.00.02
DBGSQL:               B :pkg_vsnub4 = 12010002

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 12.02.00.00
DBGSQL:               B :pkg_vsnub4 = 12020000

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 12.02.00.01
DBGSQL:               B :pkg_vsnub4 = 12020001

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 12.02.00.02
DBGSQL:               B :pkg_vsnub4 = 12020002

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = 19.05.00.00
DBGSQL:               B :pkg_vsnub4 = 19050000

DBGSQL:           AUXILIARY> declare vsn  varchar2(20); begin vsn := dbms_rcvman.getPackageVersion; :pkg_vsn := vsn; if vsn is not null then :pkg_vsnub4 := to_number(substr(vsn,1,2) || substr(vsn,4,2) || substr(vsn,7,2) || nvl(substr(vsn,10,2),'00')); end if; end; 
DBGSQL:              sqlcode = 0
DBGSQL:               B :pkg_vsn = NULL
DBGSQL:               B :pkg_vsnub4 = NULL

DBGSQL:           AUXILIARY> begin dbms_rcvman.setDebugOn; dbms_rcvman.dumpPkgState('Debug On'); end;
DBGSQL:              sqlcode = 0
      DBGRCVMAN: ENTERING dumpPkgState Debug On
      DBGRCVMAN: this_db_key=NULL
      DBGRCVMAN: this_dbinc_key=NULL
      DBGRCVMAN: this_reset_scn=NULL
      DBGRCVMAN: this_reset_time=NULL
      DBGRCVMAN: untilSCN=NULL
      DBGRCVMAN: untilTime=NULL
      DBGRCVMAN: getRA_completedAfter=NULL
      DBGRCVMAN: getRA_completedBefore=NULL
      DBGRCVMAN: getRA_likePattern=NULL
      DBGRCVMAN: getRA_containerMask=15
      DBGRCVMAN: getRA_actionMask=63
      DBGRCVMAN: computeRA_allRecords=0
      DBGRCVMAN: computeRA_fullBackups=1
      DBGRCVMAN: allIncarnations=0
      DBGRCVMAN: EXITING dumpPkgState Debug On
DBGSQL:           ENTERED krmkosqlerr

DBGSQL:            AUXILIARY> select decode(open_mode, 'MOUNTED', 0, 'READ WRITE', 1, 'READ ONLY', 1, 'READ ONLY WITH APPLY', 1, 0) into :isdbopen from v$database
DBGSQL:               sqlcode = 1507
DBGSQL:            error: ORA-01507: database not mounted (krmkosqlerr)
DBGSQL:             (krmkosqlerr)
DBGSQL:           EXITED krmkosqlerr

DBGSQL:           AUXILIARY> select sum(value) from v$sga
DBGSQL:              sqlcode = 0
DBGSQL:               D :size = 805303848

Total System Global Area     805303848 bytes

DBGSQL:           AUXILIARY> select name, value from v$sga
DBGSQL:              sqlcode = 0

DBGSQL:           AUXILIARY> FETCH
DBGSQL:              sqlcode = 0
DBGSQL:               D :field = Fixed Size
DBGSQL:               D :size = 9139752

Fixed Size                     9139752 bytes

DBGSQL:           AUXILIARY> FETCH
DBGSQL:              sqlcode = 0
DBGSQL:               D :field = Variable Size
DBGSQL:               D :size = 218103808
Variable Size                218103808 bytes

DBGSQL:           AUXILIARY> FETCH
DBGSQL:              sqlcode = 0
DBGSQL:               D :field = Database Buffers
DBGSQL:               D :size = 570425344
Database Buffers             570425344 bytes

DBGSQL:           AUXILIARY> FETCH
DBGSQL:              sqlcode = 0
DBGSQL:               D :field = Redo Buffers
DBGSQL:               D :size = 7634944
Redo Buffers                   7634944 bytes

DBGSQL:           AUXILIARY> FETCH
DBGSQL:              sqlcode = 1403
DBGMISC:          ENTERED krmkgetdb [23:18:56.356]

DBGSQL:            TARGET> select db.name, dbinc.resetlogs_time, dbinc.resetlogs_change#, db.dbid, rpad(db.name, 8, 'x'), dbinc.prior_resetlogs_time, dbinc.prior_resetlogs_change#, primary_db_unique_name, db.con_dbid into :dbname, :rltime, :rlscn, :fhdbi, :pdbname, :parent_rltime, :parent_rlscn, :prim_dbuname, :con_dbid from v$database db, v$database_incarnation dbinc where dbinc.status='CURRENT'
DBGSQL:               sqlcode = 0
DBGSQL:                D :dbname = TRMAN01
DBGSQL:                D :rltime = "25-NOV-2019 13:44:18"
DBGSQL:                D :rlscn = 1
DBGSQL:                D :fhdbi = 3810649330
DBGSQL:                D :pdbname = TRMAN01x
DBGSQL:                D :parent_rltime = NULL
DBGSQL:                D :parent_rlscn = 0
DBGSQL:                D :prim_dbuname = NULL
DBGSQL:                D :con_dbid = 3810649330

DBGSQL:            TARGET> select nvl(max(cpmid), '0'), nvl(max(cpmid), 0) into :txtparmvalue, :parmvalue from x$kcccp where cpsta in (2,3)
DBGSQL:               sqlcode = 0
DBGSQL:                D :txtparmvalue = 3818754911
DBGSQL:                D :parmvalue = 3818754911

DBGSQL:            TARGET> select upper(value) into :parmvalue from v$parameter where lower(name) = 'db_unique_name'
DBGSQL:               sqlcode = 0
DBGSQL:                D :parmvalue = TRMAN01

DBGSQL:            TARGET> select count(*) into :dbstate from v$parameter where lower(name) = '_dummy_instance' and upper(value) = 'TRUE'
DBGSQL:               sqlcode = 0
DBGSQL:                D :dbstate = 0

DBGSQL:            TARGET> select decode(value, 'TRUE', 1, 0) into :dbstate from v$option where parameter = 'Parallel backup and recovery'
DBGSQL:               sqlcode = 0
DBGSQL:                D :dbstate = 1

DBGSQL:            TARGET> select decode(value, 'TRUE', 1, 0) into :dbstate from v$option where parameter = 'Incremental backup and recovery'
DBGSQL:               sqlcode = 0
DBGSQL:                D :dbstate = 1

DBGSQL:            TARGET> select decode(value, 'TRUE', 1, 0) into :dbstate from v$option where parameter = 'Duplexed backups'
DBGSQL:               sqlcode = 0
DBGSQL:                D :dbstate = 1

DBGSQL:            TARGET> select decode(value, 'TRUE', 1, 0) into :dbstate from v$option where parameter = 'Block Media Recovery'
DBGSQL:               sqlcode = 0
DBGSQL:                D :dbstate = 1

DBGSQL:            TARGET> select decode(value, 'TRUE', 1, 0) into :dbstate from v$option where parameter = 'Point-in-time tablespace recovery'
DBGSQL:               sqlcode = 0
DBGSQL:                D :dbstate = 1

DBGSQL:            TARGET> select decode(value, 'TRUE', 1, 0) into :dbstate from v$option where parameter = 'Backup Encryption'
DBGSQL:               sqlcode = 0
DBGSQL:                D :dbstate = 1
DBGRCV:           EXITED krmkgetdb with status 1

DBGSQL:           TARGET> select controlfile_type, controlfile_change#, controlfile_sequence#, controlfile_created, decode(offr.records_used, 0, 0, offr.last_recid - offr.records_used + 1), decode(database_role, 'SNAPSHOT STANDBY', 1, 0) into :cftype, :cfscn, :cfseq, :cfcretime, :cfoffrrid, :cfsnapstby from v$database, v$controlfile_record_section offr where offr.type = 'OFFLINE RANGE'
DBGSQL:              sqlcode = 0
DBGSQL:               D :cftype = CURRENT
DBGSQL:               D :cfscn = 2377078
DBGSQL:               D :cfseq = 15708
DBGSQL:               D :cfcretime = "25-NOV-2019 13:44:18"
DBGSQL:               D :cfoffrrid = 1
DBGSQL:               D :cfsnapstby = 0
RMAN-06224: Automatic instance created
DBGANY:          EXITED krmkcaux [23:18:56.436]
DBGSQL:          ENTERED krmkosqlerr

DBGSQL:           AUXILIARY> select decode(open_mode, 'MOUNTED', 0, 'READ WRITE', 1, 'READ ONLY', 1, 'READ ONLY WITH APPLY', 1, 0) into :isdbopen from v$database
DBGSQL:              sqlcode = 1507
DBGSQL:           error: ORA-01507: database not mounted (krmkosqlerr)
DBGSQL:            (krmkosqlerr)
DBGSQL:          EXITED krmkosqlerr

DBGSQL:          AUXILIARY> select count(*) into :dbstate from v$parameter where name = 'db_create_file_dest' and value is not null
DBGSQL:             sqlcode = 0
DBGSQL:              D :dbstate = 0
DBGSQL:          ENTERED krmkosqlerr

DBGSQL:           AUXILIARY> select decode(open_mode, 'MOUNTED', 0, 'READ WRITE', 1, 'READ ONLY', 1, 'READ ONLY WITH APPLY', 1, 0) into :isdbopen from v$database
DBGSQL:              sqlcode = 1507
DBGSQL:           error: ORA-01507: database not mounted (krmkosqlerr)
DBGSQL:            (krmkosqlerr)
DBGSQL:          EXITED krmkosqlerr

DBGSQL:          AUXILIARY> begin dbms_backup_restore.setDbUniqNameTspitr(NULL); dbms_backup_restore.setDbUniqNameTspitr(:dbuniq); end;
DBGSQL:             sqlcode = 0
DBGSQL:              B :dbuniq = TRMAN01
DBGTSPITR:      EXITED krmrCheckAuxiliaryInstance with status 1

DBGSQL:         TARGET> begin    :rval := trunc(dbms_random.value(10000,99999)); end;
DBGSQL:            sqlcode = 0
DBGSQL:             B :rval = 53984
DBGTSPITR:      ENTERED krmrProcessAuxiliaryFiles
DBGMISC:         ENTERED krmknmtr [23:18:56.609]
DBGRCV:           ENTERED krmkicat
DBGRCV:            host=TARGET, transclause: 1, needuntscn: 1 haveuntscn: 1 (krmkicat)
DBGRCV:            Need to initialize target (krmkicat)
DBGRCV:            Need to initialize rcvcat (krmkicat)
DBGRCV:            Forced to recompute until scn due to resetAll (krmkicat)
DBGSQL:            ENTERED krmkosqlerr

DBGSQL:             AUXILIARY> select decode(open_mode, 'MOUNTED', 0, 'READ WRITE', 1, 'READ ONLY', 1, 'READ ONLY WITH APPLY', 1, 0) into :isdbopen from v$database
DBGSQL:                sqlcode = 1507
DBGSQL:             error: ORA-01507: database not mounted (krmkosqlerr)
DBGSQL:              (krmkosqlerr)
DBGSQL:            EXITED krmkosqlerr

DBGSQL:            TARGET> declare transclause boolean := FALSE; begin if (:transclause > 0) then transclause := TRUE; end if; dbms_rcvman.resetAll(transclause => transclause); end; 
DBGSQL:               sqlcode = 0
DBGSQL:                B :transclause = 1
       DBGRCVMAN: resetAll
       DBGRCVMAN: ENTERING setRAflags
       DBGRCVMAN: setRAflags kindMask=255 containerMask=15 actionMask=63
       DBGRCVMAN:  ENTERING setComputeRecoveryActionMasks816
       DBGRCVMAN:   ENTERING setComputeRecoveryActionMasks
       DBGRCVMAN:   EXITING setComputeRecoveryActionMasks
       DBGRCVMAN:  EXITING setComputeRecoveryActionMasks816
       DBGRCVMAN: EXITING setRAflags
       DBGRCVMAN: allIncarnations is set to FALSE
       DBGRCVMAN: getRA_likePattern=
       DBGRCVMAN: restoreTag=,tag_like=0
       DBGRCVMAN: this_cftype=CURRENT
       DBGRCVMAN: this_dbrole=PRIMARY
       DBGRCVMAN: reset transclause
       DBGRCVMAN: *****BsRecCache Statistics*****
       DBGRCVMAN: Cache size=0 hit=0
       DBGRCVMAN: rcvRecBackupAge= 0
       DBGRCVMAN: thisBackupAge= 0
       DBGRCVMAN: ENTERING setRedoLogDeletionPolicy
       DBGRCVMAN:    setRedoLogDeletionPolicy with policy = TO NONE
       DBGRCVMAN:    setRedoLogDeletionPolicy with alldest = 0
       DBGRCVMAN: redoLogDeletionPolicyDefValid = 1
       DBGRCVMAN:  ENTERING validateStandbyConfig1
       DBGRCVMAN: policy  = TO NONE
       DBGRCVMAN: alldest = 0
       DBGRCVMAN:  EXITING validateStandbyConfig1 with status   = 1
       DBGRCVMAN: EXITING setRedoLogDeletionPolicy with policy = TO NONE with alldest = 0
DBGRCV:            Until time: to_date('26.02.2020 23:17:23','DD.MM.YYYY HH24:MI:SS'), toscn: 0 (krmkicat)
DBGSQL:            ENTERED krmkosqlerr

DBGSQL:             AUXILIARY> select decode(open_mode, 'MOUNTED', 0, 'READ WRITE', 1, 'READ ONLY', 1, 'READ ONLY WITH APPLY', 1, 0) into :isdbopen from v$database
DBGSQL:                sqlcode = 1507
DBGSQL:             error: ORA-01507: database not mounted (krmkosqlerr)
DBGSQL:              (krmkosqlerr)
DBGSQL:            EXITED krmkosqlerr

DBGSQL:            AUXILIARY> select to_date('26.02.2020 23:17:23','DD.MM.YYYY HH24:MI:SS') from sys.dual
DBGSQL:               sqlcode = 0
DBGSQL:                D :mydate = "26-FEB-2020 23:17:23"

DBGSQL:            TARGET> begin    dbms_rcvman.setAllIncarnations(TRUE); end; 
DBGSQL:               sqlcode = 0
       DBGRCVMAN: allIncarnations is set to TRUE

DBGSQL:            TARGET> declare    tmpscn number; begin    dbms_rcvman.setUntilTime(:date);    tmpscn := dbms_rcvman.getUntilScn;    if (:toscn > 0) then       dbms_rcvman.setUntilScn(tmpscn + 1);    end if;    :untscn := tmpscn; end; 
DBGSQL:               sqlcode = 0
DBGSQL:                B :toscn = NULL
DBGSQL:                B :untscn = 2376934
DBGSQL:                B :date = "26-FEB-2020 23:17:23"
       DBGRCVMAN: ENTERING setUntilTime
       DBGRCVMAN: EXITING setUntilTime untilSCN=2376934
DBGANY:            Current untilscn: 2376934 [23:18:56.753] (krmkicat)
DBGRCV:           EXITED krmkicat
DBGMISC:          ENTERED krmknmtr [23:18:56.753]
DBGMISC:           ENTERED krmknmtr [23:18:56.753]
DBGMISC:            ENTERED krmktstr [23:18:56.754]

DBGSQL:              TARGET> begin if (:doupper > 0) then :name := upper(:name); end if; dbms_rcvman.translateTablespace( ts_name => :name, pdb_id => :l_pdbid); end; 
DBGSQL:                 sqlcode = 0
DBGSQL:                  B :doupper = 0
DBGSQL:                  B :name = SYSTEM
DBGSQL:                  B :l_pdbid = 1
         DBGRCVMAN: ENTERING translateTablespace
         DBGRCVMAN:  OPENING cursor translateTablespace_c in translateTablespace
         DBGRCVMAN: EXITING translateTablespace
DBGMISC:             ENTERED krmkgdf [23:18:56.777]
DBGMISC:              Retrieved file 1, created: 9, stopscn: 0, blocks: 89600 (rfno: 1, ts: SYSTEM [0]): [23:18:56.787] (krmkgdf)
DBGMISC:                 Name: /u01/oradata/TRMAN01/system01TRMAN01.dbf (krmkgdf)
DBGMISC:                 Auxname:  (krmkgdf)
DBGMISC:                 Creation Thread: 1; Creation Size : 89600 [23:18:56.788] (krmkgdf)
DBGMISC:              File 1 is online [23:18:56.788] (krmkgdf)
DBGMISC:              -- No more datafiles -- [23:18:56.791] (krmkgdf)
DBGMISC:              ENTERED krmkgbh [23:18:56.792]
DBGMISC:              EXITED krmkgbh with status No backup history required - no flags set [23:18:56.792] elapsed time [00:00:00:00.000]
DBGMISC:              ENTERED krmkLinkPrePluginDf [23:18:56.792]
DBGMISC:               Not qualified for PrePlugin translation [23:18:56.792] (krmkLinkPrePluginDf)
DBGMISC:              EXITED krmkLinkPrePluginDf with status Done [23:18:56.793] elapsed time [00:00:00:00.000]
DBGMISC:             EXITED krmkgdf [23:18:56.793] elapsed time [00:00:00:00.015]
DBGMISC:            EXITED krmktstr with address 40465344 [23:18:56.793] elapsed time [00:00:00:00.039]
DBGMISC:           EXITED krmknmtr with status DFILE [23:18:56.793] elapsed time [00:00:00:00.039]
DBGMISC:           ENTERED krmknmtr [23:18:56.794]

DBGSQL:             TARGET> begin  :l_pdbid := dbms_rcvman.translatePdbName(  pdbName => :l_pdbname,  pdbGuid => :l_pdbguid); end; 
DBGSQL:                sqlcode = 0
DBGSQL:                 B :l_pdbid = 6
DBGSQL:                 B :l_pdbguid = 9F83CA688D186D6FE053030011AC1BBD
DBGSQL:                 B :l_pdbname = TSPITR
        DBGRCVMAN: ENTERING getDataFile_1
        DBGRCVMAN:  ENTERING skipTableSpace
        DBGRCVMAN:  EXITING skipTableSpace with: FALSE
        DBGRCVMAN: EXITING getDataFile_1
        DBGRCVMAN: ENTERING getDataFile_1
        DBGRCVMAN: EXITING getDataFile_1 with no more records

DBGSQL:             TARGET> select count(*), max(create_scn)   from v$pdbs  where name = :l_pdbname
DBGSQL:                sqlcode = 0
DBGSQL:                 D :l_cnt = 1
DBGSQL:                 D :l_crescn = 2372402
DBGSQL:                 B :l_pdbname = TSPITR
DBGMISC:            ENTERED krmktstr [23:18:56.818]

DBGSQL:              TARGET> begin    :l_pdbname := dbms_rcvman.translatePdbGuid2Name(  pdbGuid => :l_pdbguid,  pdbId   => :l_pdbid); end; 
DBGSQL:                 sqlcode = 0
DBGSQL:                  B :l_pdbname = TSPITR
DBGSQL:                  B :l_pdbid = 6
DBGSQL:                  B :l_pdbguid = 9F83CA688D186D6FE053030011AC1BBD

DBGSQL:              TARGET> begin if (:doupper > 0) then :name := upper(:name); end if; dbms_rcvman.translateTablespace( ts_name => :name, pdb_id => :l_pdbid); end; 
DBGSQL:                 sqlcode = 0
DBGSQL:                  B :doupper = 0
DBGSQL:                  B :name = SYSTEM
DBGSQL:                  B :l_pdbid = 6
         DBGRCVMAN: ENTERING translateTablespace
         DBGRCVMAN:  OPENING cursor translateTablespace_c in translateTablespace
         DBGRCVMAN: EXITING translateTablespace
DBGMISC:             ENTERED krmkgdf [23:18:56.834]
DBGMISC:              Retrieved file 150, created: 2372402, stopscn: 0, blocks: 26880 (rfno: 1, ts: SYSTEM [0]): [23:18:56.846] (krmkgdf)
DBGMISC:                 Name: /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_system_h5fz1y7j_.dbf (krmkgdf)
DBGMISC:                 Auxname:  (krmkgdf)
DBGMISC:                 Creation Thread: 1; Creation Size : 26880 [23:18:56.846] (krmkgdf)
DBGMISC:              File 150 is online [23:18:56.847] (krmkgdf)
DBGMISC:              -- No more datafiles -- [23:18:56.849] (krmkgdf)
DBGMISC:              ENTERED krmkgbh [23:18:56.850]
DBGMISC:              EXITED krmkgbh with status No backup history required - no flags set [23:18:56.850] elapsed time [00:00:00:00.000]
DBGMISC:              ENTERED krmkLinkPrePluginDf [23:18:56.850]
DBGMISC:               Not qualified for PrePlugin translation [23:18:56.850] (krmkLinkPrePluginDf)
DBGMISC:              EXITED krmkLinkPrePluginDf with status Done [23:18:56.851] elapsed time [00:00:00:00.000]
DBGMISC:             EXITED krmkgdf [23:18:56.851] elapsed time [00:00:00:00.016]
DBGMISC:            EXITED krmktstr with address 40465696 [23:18:56.851] elapsed time [00:00:00:00.032]
DBGMISC:           EXITED krmknmtr with status PDB GUID [23:18:56.851] elapsed time [00:00:00:00.057]
DBGMISC:           ENTERED krmknmtr [23:18:56.852]
DBGMISC:            ENTERED krmktstr [23:18:56.852]

DBGSQL:              TARGET> begin if (:doupper > 0) then :name := upper(:name); end if; dbms_rcvman.translateTablespace( ts_name => :name, pdb_id => :l_pdbid); end; 
DBGSQL:                 sqlcode = 0
DBGSQL:                  B :doupper = 0
DBGSQL:                  B :name = UNDOTBS1
DBGSQL:                  B :l_pdbid = 1
         DBGRCVMAN: ENTERING getDataFile_1
         DBGRCVMAN:  ENTERING skipTableSpace
         DBGRCVMAN:  EXITING skipTableSpace with: FALSE
         DBGRCVMAN: EXITING getDataFile_1
         DBGRCVMAN: ENTERING getDataFile_1
         DBGRCVMAN: EXITING getDataFile_1 with no more records
         DBGRCVMAN: ENTERING translateTablespace
         DBGRCVMAN:  OPENING cursor translateTablespace_c in translateTablespace
         DBGRCVMAN: EXITING translateTablespace
DBGMISC:             ENTERED krmkgdf [23:18:56.876]
DBGMISC:              Retrieved file 5, created: 8093, stopscn: 0, blocks: 27520 (rfno: 5, ts: UNDOTBS1 [2]): [23:18:56.886] (krmkgdf)
DBGMISC:                 Name: /u01/oradata/TRMAN01/undotbs01TRMAN01.dbf (krmkgdf)
DBGMISC:                 Auxname:  (krmkgdf)
DBGMISC:                 Creation Thread: 1; Creation Size : 25600 [23:18:56.887] (krmkgdf)
DBGMISC:              File 5 is online [23:18:56.887] (krmkgdf)
DBGMISC:              -- No more datafiles -- [23:18:56.890] (krmkgdf)
DBGMISC:              ENTERED krmkgbh [23:18:56.890]
DBGMISC:              EXITED krmkgbh with status No backup history required - no flags set [23:18:56.890] elapsed time [00:00:00:00.000]
DBGMISC:              ENTERED krmkLinkPrePluginDf [23:18:56.890]
DBGMISC:               Not qualified for PrePlugin translation [23:18:56.891] (krmkLinkPrePluginDf)
DBGMISC:              EXITED krmkLinkPrePluginDf with status Done [23:18:56.891] elapsed time [00:00:00:00.000]
DBGMISC:             EXITED krmkgdf [23:18:56.891] elapsed time [00:00:00:00.015]
DBGMISC:            EXITED krmktstr with address 40465920 [23:18:56.891] elapsed time [00:00:00:00.039]
DBGMISC:           EXITED krmknmtr with status DFILE [23:18:56.892] elapsed time [00:00:00:00.040]
DBGMISC:           ENTERED krmknmtr [23:18:56.892]

DBGSQL:             TARGET> begin  :l_pdbid := dbms_rcvman.translatePdbName(  pdbName => :l_pdbname,  pdbGuid => :l_pdbguid); end; 
DBGSQL:                sqlcode = 0
DBGSQL:                 B :l_pdbid = 6
DBGSQL:                 B :l_pdbguid = 9F83CA688D186D6FE053030011AC1BBD
DBGSQL:                 B :l_pdbname = TSPITR
        DBGRCVMAN: ENTERING getDataFile_1
        DBGRCVMAN:  ENTERING skipTableSpace
        DBGRCVMAN:  EXITING skipTableSpace with: FALSE
        DBGRCVMAN: EXITING getDataFile_1
        DBGRCVMAN: ENTERING getDataFile_1
        DBGRCVMAN: EXITING getDataFile_1 with no more records

DBGSQL:             TARGET> select count(*), max(create_scn)   from v$pdbs  where name = :l_pdbname
DBGSQL:                sqlcode = 0
DBGSQL:                 D :l_cnt = 1
DBGSQL:                 D :l_crescn = 2372402
DBGSQL:                 B :l_pdbname = TSPITR
DBGMISC:            ENTERED krmktstr [23:18:56.915]

DBGSQL:              TARGET> begin    :l_pdbname := dbms_rcvman.translatePdbGuid2Name(  pdbGuid => :l_pdbguid,  pdbId   => :l_pdbid); end; 
DBGSQL:                 sqlcode = 0
DBGSQL:                  B :l_pdbname = TSPITR
DBGSQL:                  B :l_pdbid = 6
DBGSQL:                  B :l_pdbguid = 9F83CA688D186D6FE053030011AC1BBD

DBGSQL:              TARGET> begin if (:doupper > 0) then :name := upper(:name); end if; dbms_rcvman.translateTablespace( ts_name => :name, pdb_id => :l_pdbid); end; 
DBGSQL:                 sqlcode = 0
DBGSQL:                  B :doupper = 0
DBGSQL:                  B :name = UNDOTBS1
DBGSQL:                  B :l_pdbid = 6
         DBGRCVMAN: ENTERING translateTablespace
         DBGRCVMAN:  OPENING cursor translateTablespace_c in translateTablespace
         DBGRCVMAN: EXITING translateTablespace
DBGMISC:             ENTERED krmkgdf [23:18:56.932]
DBGMISC:              Retrieved file 152, created: 2372407, stopscn: 0, blocks: 27520 (rfno: 6, ts: UNDOTBS1 [2]): [23:18:56.943] (krmkgdf)
DBGMISC:                 Name: /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_undotbs1_h5fz1y7p_.dbf (krmkgdf)
DBGMISC:                 Auxname:  (krmkgdf)
DBGMISC:                 Creation Thread: 1; Creation Size : 27520 [23:18:56.943] (krmkgdf)
DBGMISC:              File 152 is online [23:18:56.944] (krmkgdf)
DBGMISC:              -- No more datafiles -- [23:18:56.946] (krmkgdf)
DBGMISC:              ENTERED krmkgbh [23:18:56.946]
DBGMISC:              EXITED krmkgbh with status No backup history required - no flags set [23:18:56.947] elapsed time [00:00:00:00.000]
DBGMISC:              ENTERED krmkLinkPrePluginDf [23:18:56.947]
DBGMISC:               Not qualified for PrePlugin translation [23:18:56.947] (krmkLinkPrePluginDf)
DBGMISC:              EXITED krmkLinkPrePluginDf with status Done [23:18:56.947] elapsed time [00:00:00:00.000]
DBGMISC:             EXITED krmkgdf [23:18:56.948] elapsed time [00:00:00:00.015]
DBGMISC:            EXITED krmktstr with address 40466400 [23:18:56.948] elapsed time [00:00:00:00.032]
DBGMISC:           EXITED krmknmtr with status PDB GUID [23:18:56.948] elapsed time [00:00:00:00.056]
DBGMISC:           ENTERED krmknmtr [23:18:56.948]
DBGMISC:            ENTERED krmktstr [23:18:56.949]

DBGSQL:              TARGET> begin if (:doupper > 0) then :name := upper(:name); end if; dbms_rcvman.translateTablespace( ts_name => :name, pdb_id => :l_pdbid); end; 
DBGSQL:                 sqlcode = 0
DBGSQL:                  B :doupper = 0
DBGSQL:                  B :name = SYSAUX
DBGSQL:                  B :l_pdbid = 1
         DBGRCVMAN: ENTERING getDataFile_1
         DBGRCVMAN:  ENTERING skipTableSpace
         DBGRCVMAN:  EXITING skipTableSpace with: FALSE
         DBGRCVMAN: EXITING getDataFile_1
         DBGRCVMAN: ENTERING getDataFile_1
         DBGRCVMAN: EXITING getDataFile_1 with no more records
         DBGRCVMAN: ENTERING translateTablespace
         DBGRCVMAN:  OPENING cursor translateTablespace_c in translateTablespace
         DBGRCVMAN: EXITING translateTablespace
DBGMISC:             ENTERED krmkgdf [23:18:56.973]
DBGMISC:              Retrieved file 3, created: 6410, stopscn: 0, blocks: 70400 (rfno: 3, ts: SYSAUX [1]): [23:18:56.983] (krmkgdf)
DBGMISC:                 Name: /u01/oradata/TRMAN01/sysaux01TRMAN01.dbf (krmkgdf)
DBGMISC:                 Auxname:  (krmkgdf)
DBGMISC:                 Creation Thread: 1; Creation Size : 70400 [23:18:56.984] (krmkgdf)
DBGMISC:              File 3 is online [23:18:56.984] (krmkgdf)
DBGMISC:              -- No more datafiles -- [23:18:56.987] (krmkgdf)
DBGMISC:              ENTERED krmkgbh [23:18:56.987]
DBGMISC:              EXITED krmkgbh with status No backup history required - no flags set [23:18:56.987] elapsed time [00:00:00:00.000]
DBGMISC:              ENTERED krmkLinkPrePluginDf [23:18:56.987]
DBGMISC:               Not qualified for PrePlugin translation [23:18:56.988] (krmkLinkPrePluginDf)
DBGMISC:              EXITED krmkLinkPrePluginDf with status Done [23:18:56.988] elapsed time [00:00:00:00.000]
DBGMISC:             EXITED krmkgdf [23:18:56.988] elapsed time [00:00:00:00.014]
DBGMISC:            EXITED krmktstr with address 40466624 [23:18:56.988] elapsed time [00:00:00:00.039]
DBGMISC:           EXITED krmknmtr with status DFILE [23:18:56.988] elapsed time [00:00:00:00.040]
DBGMISC:           ENTERED krmknmtr [23:18:56.989]

DBGSQL:             TARGET> begin  :l_pdbid := dbms_rcvman.translatePdbName(  pdbName => :l_pdbname,  pdbGuid => :l_pdbguid); end; 
DBGSQL:                sqlcode = 0
DBGSQL:                 B :l_pdbid = 6
DBGSQL:                 B :l_pdbguid = 9F83CA688D186D6FE053030011AC1BBD
DBGSQL:                 B :l_pdbname = TSPITR
        DBGRCVMAN: ENTERING getDataFile_1
        DBGRCVMAN:  ENTERING skipTableSpace
        DBGRCVMAN:  EXITING skipTableSpace with: FALSE
        DBGRCVMAN: EXITING getDataFile_1
        DBGRCVMAN: ENTERING getDataFile_1
        DBGRCVMAN: EXITING getDataFile_1 with no more records

DBGSQL:             TARGET> select count(*), max(create_scn)   from v$pdbs  where name = :l_pdbname
DBGSQL:                sqlcode = 0
DBGSQL:                 D :l_cnt = 1
DBGSQL:                 D :l_crescn = 2372402
DBGSQL:                 B :l_pdbname = TSPITR
DBGMISC:            ENTERED krmktstr [23:18:57.012]

DBGSQL:              TARGET> begin    :l_pdbname := dbms_rcvman.translatePdbGuid2Name(  pdbGuid => :l_pdbguid,  pdbId   => :l_pdbid); end; 
DBGSQL:                 sqlcode = 0
DBGSQL:                  B :l_pdbname = TSPITR
DBGSQL:                  B :l_pdbid = 6
DBGSQL:                  B :l_pdbguid = 9F83CA688D186D6FE053030011AC1BBD

DBGSQL:              TARGET> begin if (:doupper > 0) then :name := upper(:name); end if; dbms_rcvman.translateTablespace( ts_name => :name, pdb_id => :l_pdbid); end; 
DBGSQL:                 sqlcode = 0
DBGSQL:                  B :doupper = 0
DBGSQL:                  B :name = SYSAUX
DBGSQL:                  B :l_pdbid = 6
         DBGRCVMAN: ENTERING translateTablespace
         DBGRCVMAN:  OPENING cursor translateTablespace_c in translateTablespace
         DBGRCVMAN: EXITING translateTablespace
DBGMISC:             ENTERED krmkgdf [23:18:57.034]
DBGMISC:              Retrieved file 151, created: 2372405, stopscn: 0, blocks: 21120 (rfno: 4, ts: SYSAUX [1]): [23:18:57.047] (krmkgdf)
DBGMISC:                 Name: /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_sysaux_h5fz1y7m_.dbf (krmkgdf)
DBGMISC:                 Auxname:  (krmkgdf)
DBGMISC:                 Creation Thread: 1; Creation Size : 21120 [23:18:57.047] (krmkgdf)
DBGMISC:              File 151 is online [23:18:57.048] (krmkgdf)
DBGMISC:              -- No more datafiles -- [23:18:57.051] (krmkgdf)
DBGMISC:              ENTERED krmkgbh [23:18:57.051]
DBGMISC:              EXITED krmkgbh with status No backup history required - no flags set [23:18:57.051] elapsed time [00:00:00:00.000]
DBGMISC:              ENTERED krmkLinkPrePluginDf [23:18:57.052]
DBGMISC:               Not qualified for PrePlugin translation [23:18:57.052] (krmkLinkPrePluginDf)
DBGMISC:              EXITED krmkLinkPrePluginDf with status Done [23:18:57.052] elapsed time [00:00:00:00.000]
DBGMISC:             EXITED krmkgdf [23:18:57.052] elapsed time [00:00:00:00.017]
DBGMISC:            EXITED krmktstr with address 40471288 [23:18:57.053] elapsed time [00:00:00:00.040]
DBGMISC:           EXITED krmknmtr with status PDB GUID [23:18:57.053] elapsed time [00:00:00:00.064]
DBGMISC:          EXITED krmknmtr with status DFILE [23:18:57.053] elapsed time [00:00:00:00.299]
DBGMISC:          krmknmtr:  the parse tree after name translation is: [23:18:57.053] (krmknmtr)
DBGMISC:            1 DFILE
DBGMISC:                1 DF fno=1 pplfno=0 pdbid=1 pdbname=  crescn=9
DBGMISC:                   blksize=8192 blocks=89600 rfno=1
DBGMISC:                   pdbForeignDbid=0 pdbForeignCkpScn=0
DBGMISC:                   fn=/u01/oradata/TRMAN01/system01TRMAN01.dbf
DBGMISC:                   ts=SYSTEM, flags=KRMKDF_INBACKUP
DBGMISC:                  fedata: sta=0x0e crescn=9
DBGMISC:                2 DF fno=150 pplfno=0 pdbid=6 pdbname=TSPITR crescn=2372402
DBGMISC:                   blksize=8192 blocks=26880 rfno=1
DBGMISC:                   pdbForeignDbid=3681350744 pdbForeignCkpScn=1138202
DBGMISC:                   fn=/u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_system_h5fz1y7j_.dbf
DBGMISC:                   ts=TSPITR:SYSTEM, flags=KRMKDF_INBACKUP
DBGMISC:                  fedata: sta=0x0e crescn=2372402
DBGMISC:                3 DF fno=5 pplfno=0 pdbid=1 pdbname=  crescn=8093
DBGMISC:                   blksize=8192 blocks=27520 rfno=5
DBGMISC:                   pdbForeignDbid=0 pdbForeignCkpScn=0
DBGMISC:                   fn=/u01/oradata/TRMAN01/undotbs01TRMAN01.dbf
DBGMISC:                   ts=UNDOTBS1, flags=KRMKDF_INBACKUP
DBGMISC:                  fedata: sta=0x0e crescn=8093
DBGMISC:                4 DF fno=152 pplfno=0 pdbid=6 pdbname=TSPITR crescn=2372407
DBGMISC:                   blksize=8192 blocks=27520 rfno=6
DBGMISC:                   pdbForeignDbid=3681350744 pdbForeignCkpScn=1138202
DBGMISC:                   fn=/u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_undotbs1_h5fz1y7p_.dbf
DBGMISC:                   ts=TSPITR:UNDOTBS1, flags=KRMKDF_INBACKUP
DBGMISC:                  fedata: sta=0x0e crescn=2372407
DBGMISC:                5 DF fno=3 pplfno=0 pdbid=1 pdbname=  crescn=6410
DBGMISC:                   blksize=8192 blocks=70400 rfno=3
DBGMISC:                   pdbForeignDbid=0 pdbForeignCkpScn=0
DBGMISC:                   fn=/u01/oradata/TRMAN01/sysaux01TRMAN01.dbf
DBGMISC:                   ts=SYSAUX, flags=KRMKDF_INBACKUP
DBGMISC:                  fedata: sta=0x0e crescn=6410
DBGMISC:                6 DF fno=151 pplfno=0 pdbid=6 pdbname=TSPITR crescn=2372405
DBGMISC:                   blksize=8192 blocks=21120 rfno=4
DBGMISC:                   pdbForeignDbid=3681350744 pdbForeignCkpScn=1138202
DBGMISC:                   fn=/u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_sysaux_h5fz1y7m_.dbf
DBGMISC:                   ts=TSPITR:SYSAUX, flags=KRMKDF_INBACKUP
DBGMISC:                  fedata: sta=0x0e crescn=2372405
DBGMISC:         EXITED krmknmtr with status DFILE [23:18:57.062] elapsed time [00:00:00:00.453]
DBGTSPITR:       ENTERED krmrProcessAuxiliaryDf
DBGTSPITR:        Analyzing auxset datafile: /u01/oradata/TRMAN01/system01TRMAN01.dbf (cscn: 9) (krmrProcessAuxiliaryDf)
DBGRCV:           ENTERED krmklknn
DBGRCV:            Looking for newname for datafile: 1, Translate: 1, dosearch=1 (krmklknn)
DBGRCV:            Looking up in unprocessed newname list, need_dfinfo=0 (krmklknn)
DBGRCV:            ENTERED krmksearchnewname
DBGRCV:            EXITED krmksearchnewname with address 0
DBGRCV:            No newname found for datafile 1 (krmklknn)
DBGRCV:           EXITED krmklknn with address 0
DBGSQL:           ENTERED krmkosqlerr

DBGSQL:            AUXILIARY> select decode(open_mode, 'MOUNTED', 0, 'READ WRITE', 1, 'READ ONLY', 1, 'READ ONLY WITH APPLY', 1, 0) into :isdbopen from v$database
DBGSQL:               sqlcode = 1507
DBGSQL:            error: ORA-01507: database not mounted (krmkosqlerr)
DBGSQL:             (krmkosqlerr)
DBGSQL:           EXITED krmkosqlerr

DBGSQL:           AUXILIARY> begin :ofname := sys.dbms_backup_restore.convertFileName( fname   =>   :ifname, ftype   =>   :iftype, osftype =>   TRUE); end;
DBGSQL:              sqlcode = 0
DBGSQL:               B :ofname = /u01/oradata/TRMAN01/system01TRMAN01.dbf
DBGSQL:               B :ifname = /u01/oradata/TRMAN01/system01TRMAN01.dbf
DBGSQL:               B :iftype = 2
DBGTSPITR:        No name for auxset file: /u01/oradata/TRMAN01/system01TRMAN01.dbf, will signal 5001 (krmrProcessAuxiliaryDf)
DBGRCV:           ENTERED krmkckfn
DBGRCV:            Checking /u01/oradata/TRMAN01/system01TRMAN01.dbf for conflicts in target database (krmkckfn)

DBGSQL:            TARGET> begin :rc := sys.dbms_backup_restore.checkFileName(:fnp); end; 
DBGSQL:               sqlcode = 0
DBGSQL:                B :rc = 1
DBGSQL:                B :fnp = /u01/oradata/TRMAN01/system01TRMAN01.dbf
       DBGRCVMAN: ENTERING getDataFile_1
       DBGRCVMAN:  ENTERING skipTableSpace
       DBGRCVMAN:  EXITING skipTableSpace with: FALSE
       DBGRCVMAN: EXITING getDataFile_1
       DBGRCVMAN: ENTERING getDataFile_1
       DBGRCVMAN: EXITING getDataFile_1 with no more records
DBGRCV:           EXITED krmkckfn with status 1
DBGTSPITR:        ENTERED krmrProcessAuxiliaryDf
DBGTSPITR:         Analyzing auxset datafile: /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_system_h5fz1y7j_.dbf (cscn: 2372402) (krmrProcessAuxiliaryDf)
DBGRCV:            ENTERED krmklknn
DBGRCV:             Looking for newname for datafile: 150, Translate: 1, dosearch=1 (krmklknn)
DBGRCV:             Looking up in unprocessed newname list, need_dfinfo=0 (krmklknn)
DBGRCV:             ENTERED krmksearchnewname
DBGRCV:             EXITED krmksearchnewname with address 0
DBGRCV:             No newname found for datafile 150 (krmklknn)
DBGRCV:            EXITED krmklknn with address 0
DBGSQL:            ENTERED krmkosqlerr

DBGSQL:             AUXILIARY> select decode(open_mode, 'MOUNTED', 0, 'READ WRITE', 1, 'READ ONLY', 1, 'READ ONLY WITH APPLY', 1, 0) into :isdbopen from v$database
DBGSQL:                sqlcode = 1507
DBGSQL:             error: ORA-01507: database not mounted (krmkosqlerr)
DBGSQL:              (krmkosqlerr)
DBGSQL:            EXITED krmkosqlerr

DBGSQL:            AUXILIARY> begin :ofname := sys.dbms_backup_restore.convertFileName( fname   =>   :ifname, ftype   =>   :iftype, osftype =>   TRUE); end;
DBGSQL:               sqlcode = 0
DBGSQL:                B :ofname = /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_system_h5fz1y7j_.dbf
DBGSQL:                B :ifname = /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_system_h5fz1y7j_.dbf
DBGSQL:                B :iftype = 2
DBGTSPITR:         No name for auxset file: /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_system_h5fz1y7j_.dbf, will signal 5001 (krmrProcessAuxiliaryDf)
DBGRCV:            ENTERED krmkckfn
DBGRCV:             Checking /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_system_h5fz1y7j_.dbf for conflicts in target database (krmkckfn)

DBGSQL:             TARGET> begin :rc := sys.dbms_backup_restore.checkFileName(:fnp); end; 
DBGSQL:                sqlcode = 0
DBGSQL:                 B :rc = 1
DBGSQL:                 B :fnp = /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_system_h5fz1y7j_.dbf
DBGRCV:            EXITED krmkckfn with status 1
DBGTSPITR:         ENTERED krmrProcessAuxiliaryDf
DBGTSPITR:          Analyzing auxset datafile: /u01/oradata/TRMAN01/undotbs01TRMAN01.dbf (cscn: 8093) (krmrProcessAuxiliaryDf)
DBGRCV:             ENTERED krmklknn
DBGRCV:              Looking for newname for datafile: 5, Translate: 1, dosearch=1 (krmklknn)
DBGRCV:              Looking up in unprocessed newname list, need_dfinfo=0 (krmklknn)
DBGRCV:              ENTERED krmksearchnewname
DBGRCV:              EXITED krmksearchnewname with address 0
DBGRCV:              No newname found for datafile 5 (krmklknn)
DBGRCV:             EXITED krmklknn with address 0
DBGSQL:             ENTERED krmkosqlerr

DBGSQL:              AUXILIARY> select decode(open_mode, 'MOUNTED', 0, 'READ WRITE', 1, 'READ ONLY', 1, 'READ ONLY WITH APPLY', 1, 0) into :isdbopen from v$database
DBGSQL:                 sqlcode = 1507
DBGSQL:              error: ORA-01507: database not mounted (krmkosqlerr)
DBGSQL:               (krmkosqlerr)
DBGSQL:             EXITED krmkosqlerr

DBGSQL:             AUXILIARY> begin :ofname := sys.dbms_backup_restore.convertFileName( fname   =>   :ifname, ftype   =>   :iftype, osftype =>   TRUE); end;
DBGSQL:                sqlcode = 0
DBGSQL:                 B :ofname = /u01/oradata/TRMAN01/undotbs01TRMAN01.dbf
DBGSQL:                 B :ifname = /u01/oradata/TRMAN01/undotbs01TRMAN01.dbf
DBGSQL:                 B :iftype = 2
DBGTSPITR:          No name for auxset file: /u01/oradata/TRMAN01/undotbs01TRMAN01.dbf, will signal 5001 (krmrProcessAuxiliaryDf)
DBGRCV:             ENTERED krmkckfn
DBGRCV:              Checking /u01/oradata/TRMAN01/undotbs01TRMAN01.dbf for conflicts in target database (krmkckfn)

DBGSQL:              TARGET> begin :rc := sys.dbms_backup_restore.checkFileName(:fnp); end; 
DBGSQL:                 sqlcode = 0
DBGSQL:                  B :rc = 1
DBGSQL:                  B :fnp = /u01/oradata/TRMAN01/undotbs01TRMAN01.dbf
DBGRCV:             EXITED krmkckfn with status 1
DBGTSPITR:          ENTERED krmrProcessAuxiliaryDf
DBGTSPITR:           Analyzing auxset datafile: /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_undotbs1_h5fz1y7p_.dbf (cscn: 2372407) (krmrProcessAuxiliaryDf)
DBGRCV:              ENTERED krmklknn
DBGRCV:               Looking for newname for datafile: 152, Translate: 1, dosearch=1 (krmklknn)
DBGRCV:               Looking up in unprocessed newname list, need_dfinfo=0 (krmklknn)
DBGRCV:               ENTERED krmksearchnewname
DBGRCV:               EXITED krmksearchnewname with address 0
DBGRCV:               No newname found for datafile 152 (krmklknn)
DBGRCV:              EXITED krmklknn with address 0
DBGSQL:              ENTERED krmkosqlerr

DBGSQL:               AUXILIARY> select decode(open_mode, 'MOUNTED', 0, 'READ WRITE', 1, 'READ ONLY', 1, 'READ ONLY WITH APPLY', 1, 0) into :isdbopen from v$database
DBGSQL:                  sqlcode = 1507
DBGSQL:               error: ORA-01507: database not mounted (krmkosqlerr)
DBGSQL:                (krmkosqlerr)
DBGSQL:              EXITED krmkosqlerr

DBGSQL:              AUXILIARY> begin :ofname := sys.dbms_backup_restore.convertFileName( fname   =>   :ifname, ftype   =>   :iftype, osftype =>   TRUE); end;
DBGSQL:                 sqlcode = 0
DBGSQL:                  B :ofname = /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_undotbs1_h5fz1y7p_.dbf
DBGSQL:                  B :ifname = /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_undotbs1_h5fz1y7p_.dbf
DBGSQL:                  B :iftype = 2
DBGTSPITR:           No name for auxset file: /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_undotbs1_h5fz1y7p_.dbf, will signal 5001 (krmrProcessAuxiliaryDf)
DBGRCV:              ENTERED krmkckfn
DBGRCV:               Checking /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_undotbs1_h5fz1y7p_.dbf for conflicts in target database (krmkckfn)

DBGSQL:               TARGET> begin :rc := sys.dbms_backup_restore.checkFileName(:fnp); end; 
DBGSQL:                  sqlcode = 0
DBGSQL:                   B :rc = 1
DBGSQL:                   B :fnp = /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_undotbs1_h5fz1y7p_.dbf
DBGRCV:              EXITED krmkckfn with status 1
DBGTSPITR:           ENTERED krmrProcessAuxiliaryDf
DBGTSPITR:            Analyzing auxset datafile: /u01/oradata/TRMAN01/sysaux01TRMAN01.dbf (cscn: 6410) (krmrProcessAuxiliaryDf)
DBGRCV:               ENTERED krmklknn
DBGRCV:                Looking for newname for datafile: 3, Translate: 1, dosearch=1 (krmklknn)
DBGRCV:                Looking up in unprocessed newname list, need_dfinfo=0 (krmklknn)
DBGRCV:                ENTERED krmksearchnewname
DBGRCV:                EXITED krmksearchnewname with address 0
DBGRCV:                No newname found for datafile 3 (krmklknn)
DBGRCV:               EXITED krmklknn with address 0
DBGSQL:               ENTERED krmkosqlerr

DBGSQL:                AUXILIARY> select decode(open_mode, 'MOUNTED', 0, 'READ WRITE', 1, 'READ ONLY', 1, 'READ ONLY WITH APPLY', 1, 0) into :isdbopen from v$database
DBGSQL:                   sqlcode = 1507
DBGSQL:                error: ORA-01507: database not mounted (krmkosqlerr)
DBGSQL:                 (krmkosqlerr)
DBGSQL:               EXITED krmkosqlerr

DBGSQL:               AUXILIARY> begin :ofname := sys.dbms_backup_restore.convertFileName( fname   =>   :ifname, ftype   =>   :iftype, osftype =>   TRUE); end;
DBGSQL:                  sqlcode = 0
DBGSQL:                   B :ofname = /u01/oradata/TRMAN01/sysaux01TRMAN01.dbf
DBGSQL:                   B :ifname = /u01/oradata/TRMAN01/sysaux01TRMAN01.dbf
DBGSQL:                   B :iftype = 2
DBGTSPITR:            No name for auxset file: /u01/oradata/TRMAN01/sysaux01TRMAN01.dbf, will signal 5001 (krmrProcessAuxiliaryDf)
DBGRCV:               ENTERED krmkckfn
DBGRCV:                Checking /u01/oradata/TRMAN01/sysaux01TRMAN01.dbf for conflicts in target database (krmkckfn)

DBGSQL:                TARGET> begin :rc := sys.dbms_backup_restore.checkFileName(:fnp); end; 
DBGSQL:                   sqlcode = 0
DBGSQL:                    B :rc = 1
DBGSQL:                    B :fnp = /u01/oradata/TRMAN01/sysaux01TRMAN01.dbf
DBGRCV:               EXITED krmkckfn with status 1
DBGTSPITR:            ENTERED krmrProcessAuxiliaryDf
DBGTSPITR:             Analyzing auxset datafile: /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_sysaux_h5fz1y7m_.dbf (cscn: 2372405) (krmrProcessAuxiliaryDf)
DBGRCV:                ENTERED krmklknn
DBGRCV:                 Looking for newname for datafile: 151, Translate: 1, dosearch=1 (krmklknn)
DBGRCV:                 Looking up in unprocessed newname list, need_dfinfo=0 (krmklknn)
DBGRCV:                 ENTERED krmksearchnewname
DBGRCV:                 EXITED krmksearchnewname with address 0
DBGRCV:                 No newname found for datafile 151 (krmklknn)
DBGRCV:                EXITED krmklknn with address 0
DBGSQL:                ENTERED krmkosqlerr

DBGSQL:                 AUXILIARY> select decode(open_mode, 'MOUNTED', 0, 'READ WRITE', 1, 'READ ONLY', 1, 'READ ONLY WITH APPLY', 1, 0) into :isdbopen from v$database
DBGSQL:                    sqlcode = 1507
DBGSQL:                 error: ORA-01507: database not mounted (krmkosqlerr)
DBGSQL:                  (krmkosqlerr)
DBGSQL:                EXITED krmkosqlerr

DBGSQL:                AUXILIARY> begin :ofname := sys.dbms_backup_restore.convertFileName( fname   =>   :ifname, ftype   =>   :iftype, osftype =>   TRUE); end;
DBGSQL:                   sqlcode = 0
DBGSQL:                    B :ofname = /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_sysaux_h5fz1y7m_.dbf
DBGSQL:                    B :ifname = /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_sysaux_h5fz1y7m_.dbf
DBGSQL:                    B :iftype = 2
DBGTSPITR:             No name for auxset file: /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_sysaux_h5fz1y7m_.dbf, will signal 5001 (krmrProcessAuxiliaryDf)
DBGRCV:                ENTERED krmkckfn
DBGRCV:                 Checking /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_sysaux_h5fz1y7m_.dbf for conflicts in target database (krmkckfn)

DBGSQL:                 TARGET> begin :rc := sys.dbms_backup_restore.checkFileName(:fnp); end; 
DBGSQL:                    sqlcode = 0
DBGSQL:                     B :rc = 1
DBGSQL:                     B :fnp = /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_sysaux_h5fz1y7m_.dbf
DBGRCV:                EXITED krmkckfn with status 1
DBGMISC:               ENTERED krmknmtr [23:18:57.165]
DBGRCV:                 ENTERED krmkicat
DBGRCV:                  host=TARGET, transclause: 1, needuntscn: 1 haveuntscn: 1 (krmkicat)
DBGRCV:                 EXITED krmkicat
DBGMISC:                ENTERED krmknmtr [23:18:57.166]

DBGSQL:                  TARGET> begin  :l_pdbid := dbms_rcvman.translatePdbName(  pdbName => :l_pdbname,  pdbGuid => :l_pdbguid); end; 
DBGSQL:                     sqlcode = 0
DBGSQL:                      B :l_pdbid = 1
DBGSQL:                      B :l_pdbguid = 982CF63B04930255E053030011AC32A4
DBGSQL:                      B :l_pdbname = CDB$ROOT

DBGSQL:                  TARGET> select count(*), max(create_scn)   from v$pdbs  where name = :l_pdbname
DBGSQL:                     sqlcode = 0
DBGSQL:                      D :l_cnt = 0
DBGSQL:                      D :l_crescn = NULL
DBGSQL:                      B :l_pdbname = CDB$ROOT

DBGSQL:                  TARGET> begin  :l_pdbid := dbms_rcvman.translatePdbName(  pdbName => :l_pdbname,  pdbGuid => :l_pdbguid); end; 
DBGSQL:                     sqlcode = 0
DBGSQL:                      B :l_pdbid = 6
DBGSQL:                      B :l_pdbguid = 9F83CA688D186D6FE053030011AC1BBD
DBGSQL:                      B :l_pdbname = TSPITR

DBGSQL:                  TARGET> select count(*), max(create_scn)   from v$pdbs  where name = :l_pdbname
DBGSQL:                     sqlcode = 0
DBGSQL:                      D :l_cnt = 1
DBGSQL:                      D :l_crescn = 2372402
DBGSQL:                      B :l_pdbname = TSPITR
DBGMISC:                EXITED krmknmtr with status PDB GUID [23:18:57.188] elapsed time [00:00:00:00.021]
DBGMISC:                ENTERED krmktftr [23:18:57.188]

DBGSQL:                  TARGET> declare    first boolean := FALSE; begin    if (:first > 0) then       first := TRUE;    end if;    dbms_rcvman.setPdbKey(       pdbGuid => :pdbguid, first => first); end; 
DBGSQL:                     sqlcode = 0
DBGSQL:                      B :pdbguid = 982CF63B04930255E053030011AC32A4
DBGSQL:                      B :first = 1

DBGSQL:                  TARGET> declare    first boolean := FALSE; begin    if (:first > 0) then       first := TRUE;    end if;    dbms_rcvman.setPdbKey(       pdbGuid => :pdbguid, first => first); end; 
DBGSQL:                     sqlcode = 0
DBGSQL:                      B :pdbguid = 9F83CA688D186D6FE053030011AC1BBD
DBGSQL:                      B :first = 0

DBGSQL:                  TARGET> begin dbms_rcvman.translateTempfile; end; 
DBGSQL:                     sqlcode = 0

DBGSQL:                  TARGET> declare tfRec   dbms_rcvman.tfRec_t; begin dbms_rcvman.getTempfile(tfRec => tfRec); :fno := tfRec.tfNumber; :create_scn := tfRec.tfCreationSCN; :create_time := tfRec.tfCreationTime; :status := tfRec.status; if (tfRec.isSFT = 'YES') then :isSFT := 1; else :isSFT := 0; end if; :blocks := tfRec.blocks; :blocksize := tfRec.blockSize; :fname := tfRec.fileName; :tsname := tfRec.tsName; :tsno := tfRec.tsNumber; :rfno := tfRec.rfNumber; :maxsize := tfRec.maxSize; :nextsize := tfRec.nextSize; :pdbid := tfRec.pdbId; :pdbKey := tfRec.pdbKey; :pdbname := tfRec.pdbName; end; 
DBGSQL:                     sqlcode = 0
DBGSQL:                      B :fno = 1
DBGSQL:                      B :create_scn = 8461
DBGSQL:                      B :create_time = "25-NOV-2019 13:44:45"
DBGSQL:                      B :status = 30
DBGSQL:                      B :blocks = 2688
DBGSQL:                      B :blocksize = 8192
DBGSQL:                      B :fname = /u01/oradata/TRMAN01/temp01TRMAN01.dbf
DBGSQL:                      B :tsname = TEMP
DBGSQL:                      B :tsno = 3
DBGSQL:                      B :rfno = 1
DBGSQL:                      B :maxsize = 4194302
DBGSQL:                      B :nextsize = 80
DBGSQL:                      B :pdbid = 1
DBGSQL:                      B :pdbkey = 1
DBGSQL:                      B :pdbname = NULL
DBGSQL:                      B :isSFT = 0

DBGSQL:                  TARGET> declare tfRec   dbms_rcvman.tfRec_t; begin dbms_rcvman.getTempfile(tfRec => tfRec); :fno := tfRec.tfNumber; :create_scn := tfRec.tfCreationSCN; :create_time := tfRec.tfCreationTime; :status := tfRec.status; if (tfRec.isSFT = 'YES') then :isSFT := 1; else :isSFT := 0; end if; :blocks := tfRec.blocks; :blocksize := tfRec.blockSize; :fname := tfRec.fileName; :tsname := tfRec.tsName; :tsno := tfRec.tsNumber; :rfno := tfRec.rfNumber; :maxsize := tfRec.maxSize; :nextsize := tfRec.nextSize; :pdbid := tfRec.pdbId; :pdbKey := tfRec.pdbKey; :pdbname := tfRec.pdbName; end; 
DBGSQL:                     sqlcode = 0
DBGSQL:                      B :fno = 6
DBGSQL:                      B :create_scn = 2372403
DBGSQL:                      B :create_time = "26-FEB-2020 23:16:18"
DBGSQL:                      B :status = 30
DBGSQL:                      B :blocks = 2688
DBGSQL:                      B :blocksize = 8192
DBGSQL:                      B :fname = /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_temp_h5fz1y7v_.dbf
DBGSQL:                      B :tsname = TEMP
DBGSQL:                      B :tsno = 3
DBGSQL:                      B :rfno = 1
DBGSQL:                      B :maxsize = 4194302
DBGSQL:                      B :nextsize = 80
DBGSQL:                      B :pdbid = 6
DBGSQL:                      B :pdbkey = 6
DBGSQL:                      B :pdbname = TSPITR
DBGSQL:                      B :isSFT = 0

DBGSQL:                  TARGET> declare tfRec   dbms_rcvman.tfRec_t; begin dbms_rcvman.getTempfile(tfRec => tfRec); :fno := tfRec.tfNumber; :create_scn := tfRec.tfCreationSCN; :create_time := tfRec.tfCreationTime; :status := tfRec.status; if (tfRec.isSFT = 'YES') then :isSFT := 1; else :isSFT := 0; end if; :blocks := tfRec.blocks; :blocksize := tfRec.blockSize; :fname := tfRec.fileName; :tsname := tfRec.tsName; :tsno := tfRec.tsNumber; :rfno := tfRec.rfNumber; :maxsize := tfRec.maxSize; :nextsize := tfRec.nextSize; :pdbid := tfRec.pdbId; :pdbKey := tfRec.pdbKey; :pdbname := tfRec.pdbName; end; 
DBGSQL:                     sqlcode = 1403
DBGSQL:                      B :fno = NULL
DBGSQL:                      B :create_scn = NULL
DBGSQL:                      B :create_time = NULL
DBGSQL:                      B :status = NULL
DBGSQL:                      B :blocks = NULL
DBGSQL:                      B :blocksize = NULL
DBGSQL:                      B :fname = NULL
DBGSQL:                      B :tsname = NULL
DBGSQL:                      B :tsno = NULL
DBGSQL:                      B :rfno = NULL
DBGSQL:                      B :maxsize = NULL
DBGSQL:                      B :nextsize = NULL
DBGSQL:                      B :pdbid = NULL
DBGSQL:                      B :pdbkey = NULL
DBGSQL:                      B :pdbname = NULL
DBGSQL:                      B :isSFT = 0
DBGMISC:                EXITED krmktftr with address 40473656 [23:18:57.261] elapsed time [00:00:00:00.072]
DBGMISC:                krmknmtr:  the parse tree after name translation is: [23:18:57.261] (krmknmtr)
DBGMISC:                  1 TFILE
DBGMISC:                      1 TF fno=1 pdbid=1 pdbname=  crescn=         blksize=8192 blocks=2688 rfno=1
DBGMISC:                        fn=/u01/oradata/TRMAN01/temp01TRMAN01.dbf
DBGMISC:                        ts=TEMP, tfsta=KRMKTF_KCCTFONL, tfsta=KRMKTF_KCCTFRDE, tfsta=KRMKTF_KCCTFCGE, tfsta=KRMKTF_KCCTFEXO
DBGMISC:                        
DBGMISC:                      2 TF fno=6 pdbid=6 pdbname=TSPITR crescn=         blksize=8192 blocks=2688 rfno=1
DBGMISC:                        fn=/u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_temp_h5fz1y7v_.dbf
DBGMISC:                        ts=TSPITR:TEMP, tfsta=KRMKTF_KCCTFONL, tfsta=KRMKTF_KCCTFRDE, tfsta=KRMKTF_KCCTFCGE, tfsta=KRMKTF_KCCTFEXO
DBGMISC:                        
DBGMISC:               EXITED krmknmtr with status TFILE [23:18:57.263] elapsed time [00:00:00:00.098]
DBGTSPITR:             Analyzing temporary datafile: /u01/oradata/TRMAN01/temp01TRMAN01.dbf (krmrProcessAuxiliaryFiles)
DBGRCV:                ENTERED krmklkntn
DBGRCV:                 Looking for newname for tempfile: 1, Translate: 1 (krmklkntn)
DBGRCV:                 ENTERED krmksearchtnewname
DBGRCV:                 EXITED krmksearchtnewname with address 0
DBGRCV:                 No newname found for tempfile 1 (krmklkntn)
DBGRCV:                EXITED krmklkntn with address 0
DBGSQL:                ENTERED krmkosqlerr

DBGSQL:                 AUXILIARY> select decode(open_mode, 'MOUNTED', 0, 'READ WRITE', 1, 'READ ONLY', 1, 'READ ONLY WITH APPLY', 1, 0) into :isdbopen from v$database
DBGSQL:                    sqlcode = 1507
DBGSQL:                 error: ORA-01507: database not mounted (krmkosqlerr)
DBGSQL:                  (krmkosqlerr)
DBGSQL:                EXITED krmkosqlerr

DBGSQL:                AUXILIARY> begin :ofname := sys.dbms_backup_restore.convertFileName( fname   =>   :ifname, ftype   =>   :iftype, osftype =>   TRUE); end;
DBGSQL:                   sqlcode = 0
DBGSQL:                    B :ofname = /u01/oradata/TRMAN01/temp01TRMAN01.dbf
DBGSQL:                    B :ifname = /u01/oradata/TRMAN01/temp01TRMAN01.dbf
DBGSQL:                    B :iftype = 6
DBGTSPITR:             No name for tempfile: /u01/oradata/TRMAN01/temp01TRMAN01.dbf, will signal 5001 (krmrProcessAuxiliaryFiles)
DBGRCV:                ENTERED krmkckfn
DBGRCV:                 Checking /u01/oradata/TRMAN01/temp01TRMAN01.dbf for conflicts in target database (krmkckfn)

DBGSQL:                 TARGET> begin :rc := sys.dbms_backup_restore.checkFileName(:fnp); end; 
DBGSQL:                    sqlcode = 0
DBGSQL:                     B :rc = 1
DBGSQL:                     B :fnp = /u01/oradata/TRMAN01/temp01TRMAN01.dbf
DBGRCV:                EXITED krmkckfn with status 1
DBGTSPITR:             Analyzing temporary datafile: /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_temp_h5fz1y7v_.dbf (krmrProcessAuxiliaryFiles)
DBGRCV:                ENTERED krmklkntn
DBGRCV:                 Looking for newname for tempfile: 6, Translate: 1 (krmklkntn)
DBGRCV:                 ENTERED krmksearchtnewname
DBGRCV:                 EXITED krmksearchtnewname with address 0
DBGRCV:                 No newname found for tempfile 6 (krmklkntn)
DBGRCV:                EXITED krmklkntn with address 0
DBGSQL:                ENTERED krmkosqlerr

DBGSQL:                 AUXILIARY> select decode(open_mode, 'MOUNTED', 0, 'READ WRITE', 1, 'READ ONLY', 1, 'READ ONLY WITH APPLY', 1, 0) into :isdbopen from v$database
DBGSQL:                    sqlcode = 1507
DBGSQL:                 error: ORA-01507: database not mounted (krmkosqlerr)
DBGSQL:                  (krmkosqlerr)
DBGSQL:                EXITED krmkosqlerr

DBGSQL:                AUXILIARY> begin :ofname := sys.dbms_backup_restore.convertFileName( fname   =>   :ifname, ftype   =>   :iftype, osftype =>   TRUE); end;
DBGSQL:                   sqlcode = 0
DBGSQL:                    B :ofname = /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_temp_h5fz1y7v_.dbf
DBGSQL:                    B :ifname = /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_temp_h5fz1y7v_.dbf
DBGSQL:                    B :iftype = 6
DBGTSPITR:             No name for tempfile: /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_temp_h5fz1y7v_.dbf, will signal 5001 (krmrProcessAuxiliaryFiles)
DBGRCV:                ENTERED krmkckfn
DBGRCV:                 Checking /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_temp_h5fz1y7v_.dbf for conflicts in target database (krmkckfn)

DBGSQL:                 TARGET> begin :rc := sys.dbms_backup_restore.checkFileName(:fnp); end; 
DBGSQL:                    sqlcode = 0
DBGSQL:                     B :rc = 1
DBGSQL:                     B :fnp = /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_temp_h5fz1y7v_.dbf
DBGRCV:                EXITED krmkckfn with status 1
DBGTSPITR:            EXITED krmrProcessAuxiliaryFiles with status 0
DBGTSPITR:            ENTERED krmrTranslateRecSet
DBGTSPITR:             Using rcvcat, no until (krmrTranslateRecSet)
DBGTSPITR:             Looking for tablespace: TSPITR:users at scn: 2376934 (krmrTranslateRecSet)
DBGMISC:               ENTERED krmknmtr [23:18:57.289]
DBGRCV:                 ENTERED krmkicat
DBGRCV:                  host=TARGET, transclause: 1, needuntscn: 1 haveuntscn: 1 (krmkicat)
DBGRCV:                 EXITED krmkicat
DBGMISC:                ENTERED krmknmtr [23:18:57.291]
DBGMISC:                 ENTERED krmknmtr [23:18:57.291]

DBGSQL:                   TARGET> begin  :l_pdbid := dbms_rcvman.translatePdbName(  pdbName => :l_pdbname,  pdbGuid => :l_pdbguid); end; 
DBGSQL:                      sqlcode = 0
DBGSQL:                       B :l_pdbid = 6
DBGSQL:                       B :l_pdbguid = 9F83CA688D186D6FE053030011AC1BBD
DBGSQL:                       B :l_pdbname = TSPITR

DBGSQL:                   TARGET> select count(*), max(create_scn)   from v$pdbs  where name = :l_pdbname
DBGSQL:                      sqlcode = 0
DBGSQL:                       D :l_cnt = 1
DBGSQL:                       D :l_crescn = 2372402
DBGSQL:                       B :l_pdbname = TSPITR
DBGMISC:                  ENTERED krmktstr [23:18:57.301]

DBGSQL:                    TARGET> begin    :l_pdbname := dbms_rcvman.translatePdbGuid2Name(  pdbGuid => :l_pdbguid,  pdbId   => :l_pdbid); end; 
DBGSQL:                       sqlcode = 0
DBGSQL:                        B :l_pdbname = TSPITR
DBGSQL:                        B :l_pdbid = 6
DBGSQL:                        B :l_pdbguid = 9F83CA688D186D6FE053030011AC1BBD

DBGSQL:                    TARGET> begin if (:doupper > 0) then :name := upper(:name); end if; dbms_rcvman.translateTablespace( ts_name => :name, pdb_id => :l_pdbid); end; 
DBGSQL:                       sqlcode = 0
DBGSQL:                        B :doupper = 1
DBGSQL:                        B :name = USERS
DBGSQL:                        B :l_pdbid = 6
               DBGRCVMAN: ENTERING translateTablespace
               DBGRCVMAN:  OPENING cursor translateTablespace_c in translateTablespace
               DBGRCVMAN: EXITING translateTablespace
DBGMISC:                   ENTERED krmkgdf [23:18:57.318]
DBGMISC:                    Retrieved file 153, created: 2373136, stopscn: 0, blocks: 12800 (rfno: 153, ts: USERS [4]): [23:18:57.330] (krmkgdf)
DBGMISC:                       Name: /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_users_h5fz28r5_.dbf (krmkgdf)
DBGMISC:                       Auxname:  (krmkgdf)
DBGMISC:                       Creation Thread: 1; Creation Size : 12800 [23:18:57.331] (krmkgdf)
DBGMISC:                    File 153 is online [23:18:57.331] (krmkgdf)
DBGMISC:                    -- No more datafiles -- [23:18:57.334] (krmkgdf)
DBGMISC:                    ENTERED krmkgbh [23:18:57.334]
DBGMISC:                    EXITED krmkgbh with status No backup history required - no flags set [23:18:57.335] elapsed time [00:00:00:00.000]
DBGMISC:                    ENTERED krmkLinkPrePluginDf [23:18:57.335]
DBGMISC:                     Not qualified for PrePlugin translation [23:18:57.335] (krmkLinkPrePluginDf)
DBGMISC:                    EXITED krmkLinkPrePluginDf with status Done [23:18:57.336] elapsed time [00:00:00:00.000]
DBGMISC:                   EXITED krmkgdf [23:18:57.336] elapsed time [00:00:00:00.017]
DBGMISC:                  EXITED krmktstr with address 40474712 [23:18:57.336] elapsed time [00:00:00:00.035]
DBGMISC:                 EXITED krmknmtr with status PDB GUID [23:18:57.336] elapsed time [00:00:00:00.045]
DBGMISC:                EXITED krmknmtr with status DFILE [23:18:57.337] elapsed time [00:00:00:00.046]
DBGMISC:                krmknmtr:  the parse tree after name translation is: [23:18:57.337] (krmknmtr)
DBGMISC:                  1 DFILE
DBGMISC:                      1 DF fno=153 pplfno=0 pdbid=6 pdbname=TSPITR crescn=2373136
DBGMISC:                         blksize=8192 blocks=12800 rfno=153
DBGMISC:                         pdbForeignDbid=0 pdbForeignCkpScn=0
DBGMISC:                         fn=/u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_users_h5fz28r5_.dbf
DBGMISC:                         ts=TSPITR:USERS, flags=KRMKDF_INBACKUP
DBGMISC:                        fedata: sta=0x0e crescn=2373136
DBGMISC:               EXITED krmknmtr with status DFILE [23:18:57.339] elapsed time [00:00:00:00.049]
DBGTSPITR:             Looking for tablespace: TSPITR:USERS with no until (krmrTranslateRecSet)
DBGMISC:               ENTERED krmknmtr [23:18:57.339]
DBGRCV:                 ENTERED krmkicat
DBGRCV:                  host=TARGET, transclause: 1, needuntscn: 0 haveuntscn: 1 (krmkicat)
DBGRCV:                  Target already initialized (krmkicat)
DBGRCV:                  Need to initialize rcvcat (krmkicat)
DBGRCV:                  Need to set new until clause (krmkicat)
DBGSQL:                  ENTERED krmkosqlerr

DBGSQL:                   AUXILIARY> select decode(open_mode, 'MOUNTED', 0, 'READ WRITE', 1, 'READ ONLY', 1, 'READ ONLY WITH APPLY', 1, 0) into :isdbopen from v$database
DBGSQL:                      sqlcode = 1507
DBGSQL:                   error: ORA-01507: database not mounted (krmkosqlerr)
DBGSQL:                    (krmkosqlerr)
DBGSQL:                  EXITED krmkosqlerr

DBGSQL:                  TARGET> declare transclause boolean := FALSE; begin if (:transclause > 0) then transclause := TRUE; end if; dbms_rcvman.resetAll(transclause => transclause); end; 
DBGSQL:                     sqlcode = 0
DBGSQL:                      B :transclause = 1
             DBGRCVMAN: ENTERING getDataFile_1
             DBGRCVMAN:  ENTERING skipTableSpace
             DBGRCVMAN:  EXITING skipTableSpace with: FALSE
             DBGRCVMAN: EXITING getDataFile_1
             DBGRCVMAN: ENTERING getDataFile_1
             DBGRCVMAN: EXITING getDataFile_1 with no more records
             DBGRCVMAN: resetAll
             DBGRCVMAN: ENTERING setRAflags
             DBGRCVMAN: setRAflags kindMask=255 containerMask=15 actionMask=63
             DBGRCVMAN:  ENTERING setComputeRecoveryActionMasks816
             DBGRCVMAN:   ENTERING setComputeRecoveryActionMasks
             DBGRCVMAN:   EXITING setComputeRecoveryActionMasks
             DBGRCVMAN:  EXITING setComputeRecoveryActionMasks816
             DBGRCVMAN: EXITING setRAflags
             DBGRCVMAN: allIncarnations is set to FALSE
             DBGRCVMAN: getRA_likePattern=
             DBGRCVMAN: restoreTag=,tag_like=0
             DBGRCVMAN: this_cftype=CURRENT
             DBGRCVMAN: this_dbrole=PRIMARY
             DBGRCVMAN: reset transclause
             DBGRCVMAN: *****BsRecCache Statistics*****
             DBGRCVMAN: Cache size=0 hit=0
             DBGRCVMAN: rcvRecBackupAge= 0
             DBGRCVMAN: thisBackupAge= 0
             DBGRCVMAN: ENTERING setRedoLogDeletionPolicy
             DBGRCVMAN:    setRedoLogDeletionPolicy with policy = TO NONE
             DBGRCVMAN:    setRedoLogDeletionPolicy with alldest = 0
             DBGRCVMAN: redoLogDeletionPolicyDefValid = 1
             DBGRCVMAN:  ENTERING validateStandbyConfig1
             DBGRCVMAN: policy  = TO NONE
             DBGRCVMAN: alldest = 0
             DBGRCVMAN:  EXITING validateStandbyConfig1 with status   = 1
             DBGRCVMAN: EXITING setRedoLogDeletionPolicy with policy = TO NONE with alldest = 0
DBGANY:                  No untilscn in effect [23:18:57.471] (krmkicat)
DBGRCV:                 EXITED krmkicat
DBGMISC:                ENTERED krmknmtr [23:18:57.472]
DBGMISC:                 ENTERED krmknmtr [23:18:57.472]

DBGSQL:                   TARGET> begin  :l_pdbid := dbms_rcvman.translatePdbName(  pdbName => :l_pdbname,  pdbGuid => :l_pdbguid); end; 
DBGSQL:                      sqlcode = 0
DBGSQL:                       B :l_pdbid = 6
DBGSQL:                       B :l_pdbguid = 9F83CA688D186D6FE053030011AC1BBD
DBGSQL:                       B :l_pdbname = TSPITR
DBGMISC:                  ENTERED krmktstr [23:18:57.479]

DBGSQL:                    TARGET> begin    :l_pdbname := dbms_rcvman.translatePdbGuid2Name(  pdbGuid => :l_pdbguid,  pdbId   => :l_pdbid); end; 
DBGSQL:                       sqlcode = 0
DBGSQL:                        B :l_pdbname = TSPITR
DBGSQL:                        B :l_pdbid = 6
DBGSQL:                        B :l_pdbguid = 9F83CA688D186D6FE053030011AC1BBD

DBGSQL:                    TARGET> begin if (:doupper > 0) then :name := upper(:name); end if; dbms_rcvman.translateTablespace( ts_name => :name, pdb_id => :l_pdbid); end; 
DBGSQL:                       sqlcode = 0
DBGSQL:                        B :doupper = 1
DBGSQL:                        B :name = USERS
DBGSQL:                        B :l_pdbid = 6
               DBGRCVMAN: ENTERING translateTablespace
               DBGRCVMAN:  OPENING cursor translateTablespace_c in translateTablespace
               DBGRCVMAN: EXITING translateTablespace
DBGMISC:                   ENTERED krmkgdf [23:18:57.501]
DBGMISC:                    Retrieved file 153, created: 2373136, stopscn: 0, blocks: 12800 (rfno: 153, ts: USERS [4]): [23:18:57.510] (krmkgdf)
DBGMISC:                       Name: /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_users_h5fz28r5_.dbf (krmkgdf)
DBGMISC:                       Auxname:  (krmkgdf)
DBGMISC:                       Creation Thread: 1; Creation Size : 12800 [23:18:57.511] (krmkgdf)
DBGMISC:                    File 153 is online [23:18:57.511] (krmkgdf)
DBGMISC:                    -- No more datafiles -- [23:18:57.514] (krmkgdf)
DBGMISC:                    ENTERED krmkgbh [23:18:57.514]
DBGMISC:                    EXITED krmkgbh with status No backup history required - no flags set [23:18:57.514] elapsed time [00:00:00:00.000]
DBGMISC:                    ENTERED krmkLinkPrePluginDf [23:18:57.515]
DBGMISC:                     Not qualified for PrePlugin translation [23:18:57.515] (krmkLinkPrePluginDf)
DBGMISC:                    EXITED krmkLinkPrePluginDf with status Done [23:18:57.515] elapsed time [00:00:00:00.000]
DBGMISC:                   EXITED krmkgdf [23:18:57.515] elapsed time [00:00:00:00.014]
DBGMISC:                  EXITED krmktstr with address 40475512 [23:18:57.516] elapsed time [00:00:00:00.036]
DBGMISC:                 EXITED krmknmtr with status PDB GUID [23:18:57.516] elapsed time [00:00:00:00.043]
DBGMISC:                EXITED krmknmtr with status DFILE [23:18:57.516] elapsed time [00:00:00:00.044]
DBGMISC:                krmknmtr:  the parse tree after name translation is: [23:18:57.517] (krmknmtr)
DBGMISC:                  1 DFILE
DBGMISC:                      1 DF fno=153 pplfno=0 pdbid=6 pdbname=TSPITR crescn=2373136
DBGMISC:                         blksize=8192 blocks=12800 rfno=153
DBGMISC:                         pdbForeignDbid=0 pdbForeignCkpScn=0
DBGMISC:                         fn=/u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_users_h5fz28r5_.dbf
DBGMISC:                         ts=TSPITR:USERS, flags=KRMKDF_INBACKUP
DBGMISC:                        fedata: sta=0x0e crescn=2373136
DBGMISC:               EXITED krmknmtr with status DFILE [23:18:57.519] elapsed time [00:00:00:00.180]
DBGTSPITR:             ENTERED krmrProcessRecSetFiles
DBGRCV:                 ENTERED krmklknn
DBGRCV:                  Looking for newname for datafile: 153, Translate: 1, dosearch=1 (krmklknn)
DBGRCV:                  Looking up in unprocessed newname list, need_dfinfo=0 (krmklknn)
DBGRCV:                  ENTERED krmksearchnewname
DBGRCV:                  EXITED krmksearchnewname with address 0
DBGRCV:                  No newname found for datafile 153 (krmklknn)
DBGRCV:                 EXITED krmklknn with address 0
DBGTSPITR:              ENTERED krmrHandleRestoreRecSet
DBGTSPITR:               Will restore to original filename for recset file: /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_users_h5fz28r5_.dbf (krmrHandleRestoreRecSet)
DBGTSPITR:              EXITED krmrHandleRestoreRecSet
DBGTSPITR:             EXITED krmrProcessRecSetFiles with status 1
DBGRCV:                ENTERED krmkvts
DBGRCV:                 Checking tablespace TSPITR:USERS, creation scn: 2373136 (krmkvts)

DBGSQL:                 TARGET> declare tsnum binary_integer; begin  select ts.ts# into tsnum from v$tablespace ts where ts.name = :ltsnam and ts.con_id = :pdbid; :ret := sys.dbms_backup_restore.validateTableSpace( tsid  => tsnum, cSCN  => :lcscn, pdbId => :pdbid); end; 
DBGSQL:                    sqlcode = 0
DBGSQL:                     B :ret = 1
DBGSQL:                     B :ltsnam = USERS
DBGSQL:                     B :lcscn = 2373136
DBGSQL:                     B :pdbid = 6
            DBGRCVMAN: ENTERING getDataFile_1
            DBGRCVMAN:  ENTERING skipTableSpace
            DBGRCVMAN:  EXITING skipTableSpace with: FALSE
            DBGRCVMAN: EXITING getDataFile_1
            DBGRCVMAN: ENTERING getDataFile_1
            DBGRCVMAN: EXITING getDataFile_1 with no more records
DBGRCV:                EXITED krmkvts with status 1 (TRUE)
RMAN-05070: Running TRANSPORT_SET_CHECK on recovery set tablespaces

DBGSQL:                TARGET> select sys_context('userenv', 'con_name') into :pdbname from dual
DBGSQL:                   sqlcode = 0
DBGSQL:                    D :pdbname = CDB$ROOT

DBGSQL:                TARGET> select sys_context('userenv', 'cdb_name') into :cdbname from dual
DBGSQL:                   sqlcode = 0
DBGSQL:                    D :cdbname = TRMAN01

DBGSQL:                TARGET> alter session set container = TSPITR
DBGSQL:                   sqlcode = 0

DBGSQL:                TARGET> 
DBGSQL:                   begin 
DBGSQL:                      sys.dbms_tts.transport_set_check(' USERS', true, true); 
DBGSQL:                   end; 
DBGSQL:                
DBGSQL:                   sqlcode = 0

DBGSQL:                TARGET> 
DBGSQL:                   select violations 
DBGSQL:                     into :violap 
DBGSQL:                     from transport_set_violations 
DBGSQL:                
DBGSQL:                   sqlcode = 0

DBGSQL:                TARGET> FETCH
DBGSQL:                   sqlcode = 1403

DBGSQL:                TARGET> alter session set container = CDB$ROOT
DBGSQL:                   sqlcode = 0
RMAN-05071: TRANSPORT_SET_CHECK completed successfully
DBGTSPITR:            EXITED krmrTranslateRecSet with status 1
RMAN-06221: 
Removing automatic instance
DBGSQL:               ENTERED krmkosqlerr

DBGSQL:                AUXILIARY> select decode(open_mode, 'MOUNTED', 0, 'READ WRITE', 1, 'READ ONLY', 1, 'READ ONLY WITH APPLY', 1, 0) into :isdbopen from v$database
DBGSQL:                   sqlcode = 1507
DBGSQL:                error: ORA-01507: database not mounted (krmkosqlerr)
DBGSQL:                 (krmkosqlerr)
DBGSQL:               EXITED krmkosqlerr

DBGSQL:               AUXILIARY> ROLLBACK WORK
DBGSQL:                  sqlcode = 0
DBGMISC:              SHUTDB
DBGMISC:                1 CLOKW
DBGMISC:                2 ABORT
RMAN-06225: shutting down automatic instance 
DBGSQL:               ENTERED krmkosqlerr

DBGSQL:                AUXILIARY> select decode(open_mode, 'MOUNTED', 0, 'READ WRITE', 1, 'READ ONLY', 1, 'READ ONLY WITH APPLY', 1, 0) into :isdbopen from v$database
DBGSQL:                   sqlcode = 1507
DBGSQL:                error: ORA-01507: database not mounted (krmkosqlerr)
DBGSQL:                 (krmkosqlerr)
DBGSQL:               EXITED krmkosqlerr
DBGSQL:               ENTERED krmkosqlerr

DBGSQL:                AUXILIARY> select decode(open_mode, 'MOUNTED', 0, 'READ WRITE', 1, 'READ ONLY', 1, 'READ ONLY WITH APPLY', 1, 0) into :isdbopen from v$database
DBGSQL:                   sqlcode = 1507
DBGSQL:                error: ORA-01507: database not mounted (krmkosqlerr)
DBGSQL:                 (krmkosqlerr)
DBGSQL:               EXITED krmkosqlerr

DBGSQL:               AUXILIARY> select decode(status, 'OPEN', 1, 0), decode(archiver, 'FAILED', 1, 0), decode(database_status, 'SUSPENDED', 1, 0) into :status, :archstuck, :dbsuspended from v$instance
DBGSQL:                  sqlcode = 0
DBGSQL:                   D :status = 0
DBGSQL:                   D :archstuck = 0
DBGSQL:                   D :dbsuspended = 0

DBGSQL:               AUXILIARY> select value into :vcomp_txt from  v$parameter where name = 'compatible'
DBGSQL:                  sqlcode = 0
DBGSQL:                   D :vcomp_txt = 19.0.0

DBGSQL:               AUXILIARY> declare dot1st number; dot2nd number; dot3rd number; comptxt varchar2(255) := :vcomp_txt; begin comptxt := comptxt || '.0.0'; dot1st := instr(comptxt, '.', 1, 1); dot2nd := instr(comptxt, '.', 1, 2); dot3rd := instr(comptxt, '.', 1, 3); comptxt :=  lpad(substr(comptxt, 1, dot1st - 1), 2, '0') || lpad(substr(comptxt, dot1st + 1, dot2nd - dot1st - 1), 2, '0')  || lpad(substr(comptxt, dot2nd + 1, dot3rd - dot2nd - 1), 2, '0');:vcomp_ub4 := to_number(comptxt); end;
DBGSQL:                  sqlcode = 0
DBGSQL:                   B :vcomp_ub4 = 190000
DBGSQL:                   B :vcomp_txt = 19.0.0
DBGMISC:              krmkpdbs(): vcomp_txt:19.0.0 vcomp_ub4:190000 flags:0 [23:19:01.062]
DBGMISC:              krmqacen() [23:19:01.062]
DBGMISC:              krmqacen() : Exit [23:19:01.063]
DBGRPC:               krmxcd - removing context for channel clone_default, keep=2
DBGRPC:               krmxpoc - clearing channel clone_default
DBGRPC:               krmxpocx - cleaning polling context for channel clone_default
DBGRPC:               krmxpocx - cleaning clone polling channel
DBGRPC:               krmxpocx - closing the cursor
DBGRPC:               krmxpocx - logging off from oracle
DBGRPC:               krmxpocx - freeing krmxpon
DBGRPC:               krmxpocx - clone polling channel cleaned up
DBGRPC:               krmxpoc - channel clone_default, freeing polling context
DBGRPC:               krmxcd - disconnecting
DBGRPC:               krmxcd - context removed
RMAN-06402: Oracle instance shut down

DBGSQL:               TARGET> begin sys.dbms_backup_restore.manageAuxInstance(:lorasid, :lclean); end; 
DBGSQL:                  sqlcode = 0
DBGSQL:                   B :lorasid = lzww
DBGSQL:                   B :lclean = 1
RMAN-06226: Automatic instance removed
DBGRCV:               ENTERED krmkdelf
DBGRCV:               EXITED krmkdelf
DBGRCV:               ENTERED krmkdelf
DBGRCV:               EXITED krmkdelf
DBGRCV:               ENTERED krmkrmrecnewnames
DBGRCV:               EXITED krmkrmrecnewnames
DBGMISC:              krmicomp: error 5002 signalled during compilation [23:19:02.394]
DBGMISC:              ENTERED krmkmrsr [23:19:02.395]

DBGSQL:                TARGET> select decode(status, 'OPEN', 1, 0), decode(archiver, 'FAILED', 1, 0), decode(database_status, 'SUSPENDED', 1, 0) into :status, :archstuck, :dbsuspended from v$instance
DBGSQL:                   sqlcode = 0
DBGSQL:                    D :status = 1
DBGSQL:                    D :archstuck = 0
DBGSQL:                    D :dbsuspended = 0

DBGSQL:                TARGET> select decode(open_mode, 'READ WRITE', 1, 0) into :read_write from v$database
DBGSQL:                   sqlcode = 0
DBGSQL:                    D :read_write = 1

DBGSQL:                TARGET> select value into :vcomp_txt from  v$parameter where name = 'compatible'
DBGSQL:                   sqlcode = 0
DBGSQL:                    D :vcomp_txt = 19.0.0

DBGSQL:                TARGET> declare dot1st number; dot2nd number; dot3rd number; comptxt varchar2(255) := :vcomp_txt; begin comptxt := comptxt || '.0.0'; dot1st := instr(comptxt, '.', 1, 1); dot2nd := instr(comptxt, '.', 1, 2); dot3rd := instr(comptxt, '.', 1, 3); comptxt :=  lpad(substr(comptxt, 1, dot1st - 1), 2, '0') || lpad(substr(comptxt, dot1st + 1, dot2nd - dot1st - 1), 2, '0')  || lpad(substr(comptxt, dot2nd + 1, dot3rd - dot2nd - 1), 2, '0');:vcomp_ub4 := to_number(comptxt); end;
DBGSQL:                   sqlcode = 0
DBGSQL:                    B :vcomp_ub4 = 190000
DBGSQL:                    B :vcomp_txt = 19.0.0
DBGMISC:               krmkpdbs(): vcomp_txt:19.0.0 vcomp_ub4:190000 flags:5 [23:19:02.429]
DBGMISC:                Skipping calculating MBYTES/INPUT/OUTPUT_BYTES for  rec id 539 [23:19:02.430] (krmkmrsr)

DBGSQL:                TARGET> begin sys.dbms_backup_restore.commitRmanStatusRow( row_id    => :row_id, row_stamp => :row_stamp, mbytes    => :mb, status    => :status, ibytes    => :ib, obytes    => :ob, odevtype  => :odevtype); end;
DBGSQL:                   sqlcode = 0
DBGSQL:                    B :row_id = 539
DBGSQL:                    B :row_stamp = 1033427910
DBGSQL:                    B :mb = 0
DBGSQL:                    B :status = 12
DBGSQL:                    B :ib = 0
DBGSQL:                    B :ob = 0
DBGSQL:                    B :odevtype = 
DBGMISC:              EXITED krmkmrsr [23:19:02.446] elapsed time [00:00:00:00.051]
DBGMISC:              ENTERED krmkjcl [23:19:02.446]
DBGMISC:              EXITED krmkjcl [23:19:02.447] elapsed time [00:00:00:00.000]
DBGMISC:              error recovery releasing channel resources [23:19:02.447]
DBGRPC:               krmxcr - channel ORA_DISK_1 resetted
DBGRPC:               krmxcr - channel default resetted
DBGMISC:              ENTERED krmice [23:19:02.448]
DBGMISC:               command to be compiled and executed is: cleanup  [23:19:02.448] (krmice)
DBGMISC:               command after this command is: NONE  [23:19:02.448] (krmice)
DBGMISC:               current incarnation does not matter for cleanup [23:19:02.448] (krmice)
DBGMISC:               ENTERED krmicomp [23:19:02.449]
DBGMISC:                ENTERED krmkomp [23:19:02.449]
DBGRCV:                  ENTERED krmkucls
DBGRCV:                  EXITED krmkucls with address 0
DBGMISC:                 krmkcomp - Name translation defaults to catalog - 2 [23:19:02.450] (krmkomp)
DBGMISC:                 ENTERED krmknmtr [23:19:02.450]
DBGMISC:                 EXITED krmknmtr with status cleanup [23:19:02.450] elapsed time [00:00:00:00.000]
DBGMISC:                 ENTERED krmkdps [23:19:02.450]

DBGSQL:                   TARGET> select decode(status, 'OPEN', 1, 0), decode(archiver, 'FAILED', 1, 0), decode(database_status, 'SUSPENDED', 1, 0) into :status, :archstuck, :dbsuspended from v$instance
DBGSQL:                      sqlcode = 0
DBGSQL:                       D :status = 1
DBGSQL:                       D :archstuck = 0
DBGSQL:                       D :dbsuspended = 0

DBGSQL:                   TARGET> select decode(open_mode, 'READ WRITE', 1, 0) into :read_write from v$database
DBGSQL:                      sqlcode = 0
DBGSQL:                       D :read_write = 1

DBGSQL:                   TARGET> select value into :vcomp_txt from  v$parameter where name = 'compatible'
DBGSQL:                      sqlcode = 0
DBGSQL:                       D :vcomp_txt = 19.0.0

DBGSQL:                   TARGET> declare dot1st number; dot2nd number; dot3rd number; comptxt varchar2(255) := :vcomp_txt; begin comptxt := comptxt || '.0.0'; dot1st := instr(comptxt, '.', 1, 1); dot2nd := instr(comptxt, '.', 1, 2); dot3rd := instr(comptxt, '.', 1, 3); comptxt :=  lpad(substr(comptxt, 1, dot1st - 1), 2, '0') || lpad(substr(comptxt, dot1st + 1, dot2nd - dot1st - 1), 2, '0')  || lpad(substr(comptxt, dot2nd + 1, dot3rd - dot2nd - 1), 2, '0');:vcomp_ub4 := to_number(comptxt); end;
DBGSQL:                      sqlcode = 0
DBGSQL:                       B :vcomp_ub4 = 190000
DBGSQL:                       B :vcomp_txt = 19.0.0
DBGMISC:                  krmkpdbs(): vcomp_txt:19.0.0 vcomp_ub4:190000 flags:5 [23:19:02.474]
DBGMISC:                  krmkdps: this_db_key=1 [23:19:02.477]
DBGMISC:                  krmkdps: this_dbinc_key=1 [23:19:02.479]
DBGMISC:                  krmkdps: this_reset_scn=1 [23:19:02.482]
DBGMISC:                  krmkdps: this_reset_time=25-NOV-2019 13:44:18 [23:19:02.484]
DBGMISC:                  krmkdps: untilSCN=NULL [23:19:02.486]
DBGMISC:                  krmkdps: untilTime=NULL [23:19:02.488]
DBGMISC:                  krmkdps: getRA_completedAfter=NULL [23:19:02.491]
DBGMISC:                  krmkdps: getRA_completedBefore=NULL [23:19:02.493]
DBGMISC:                  krmkdps: getRA_likePattern=NULL [23:19:02.495]
DBGMISC:                  krmkdps: getRA_containerMask=15 [23:19:02.497]
DBGMISC:                  krmkdps: getRA_actionMask=63 [23:19:02.500]
DBGMISC:                  krmkdps: computeRA_allRecords=0 [23:19:02.502]
DBGMISC:                  krmkdps: computeRA_fullBackups=1 [23:19:02.504]
DBGMISC:                  krmkdps: allIncarnations=0 [23:19:02.506]
DBGMISC:                 EXITED krmkdps [23:19:02.508] elapsed time [00:00:00:00.058]
DBGMISC:                EXITED krmkomp [23:19:02.509] elapsed time [00:00:00:00.059]
DBGPLSQL:               the compiled command tree is: [23:19:02.509] (krmicomp)
DBGPLSQL:                 1 CMD type=cleanup cmdid=1 status=NOT STARTED
DBGPLSQL:                     1 STEPstepid=1 cmdid=1 status=NOT STARTED
DBGPLSQL:                         1 TEXTNOD = --
DBGPLSQL:                         2 TEXTNOD = declare
DBGPLSQL:                         3 TEXTNOD =   /* device status variables */
DBGPLSQL:                         4 TEXTNOD =   state       binary_integer;
DBGPLSQL:                         5 TEXTNOD =   devtype     varchar2(512);
DBGPLSQL:                         6 TEXTNOD =   name        varchar2(512);
DBGPLSQL:                         7 TEXTNOD =   bufsz       binary_integer;
DBGPLSQL:                         8 TEXTNOD =   bufcnt      binary_integer;
DBGPLSQL:                         9 TEXTNOD =   kbytes      number;
DBGPLSQL:                        10 TEXTNOD =   readrate    binary_integer;
DBGPLSQL:                        11 TEXTNOD =   parallel    binary_integer;
DBGPLSQL:                        12 TEXTNOD =   thread      number;
DBGPLSQL:                        13 TEXTNOD =   kcrmx_recs  number;
DBGPLSQL:                        14 TEXTNOD =   autochn     number := 0;
DBGPLSQL:                        15 TEXTNOD =  
DBGPLSQL:                        16 TEXTNOD =   mr_not_started exception;
DBGPLSQL:                        17 TEXTNOD =   pragma exception_init(mr_not_started, -1112);
DBGPLSQL:                        18 TEXTNOD =   db_not_mounted exception;
DBGPLSQL:                        19 TEXTNOD =   pragma exception_init(db_not_mounted, -1507);
DBGPLSQL:                        20 TEXTNOD = begin
DBGPLSQL:                        21 TEXTNOD =   
DBGPLSQL:                        22 PRMVAL =  autochn := 1;
DBGPLSQL:                        23 TEXTNOD =   begin
DBGPLSQL:                        24 TEXTNOD =     krmicd.execSql('select count(*) from x$dual');
DBGPLSQL:                        25 TEXTNOD =   exception
DBGPLSQL:                        26 TEXTNOD =     when others then
DBGPLSQL:                        27 TEXTNOD =       krmicd.clearErrors;
DBGPLSQL:                        28 TEXTNOD =   end;
DBGPLSQL:                        29 TEXTNOD =   sys.dbms_backup_restore.backupCancel;
DBGPLSQL:                        30 TEXTNOD =   sys.dbms_backup_restore.restoreCancel(FALSE);
DBGPLSQL:                        31 TEXTNOD =   begin
DBGPLSQL:                        32 TEXTNOD =     sys.dbms_backup_restore.proxyCancel;
DBGPLSQL:                        33 TEXTNOD =   exception
DBGPLSQL:                        34 TEXTNOD =      when others then
DBGPLSQL:                        35 TEXTNOD =         krmicd.clearErrors;
DBGPLSQL:                        36 TEXTNOD =   end;
DBGPLSQL:                        37 TEXTNOD =   sys.dbms_backup_restore.cfileUseCurrent;              -- release enqueue
DBGPLSQL:                        38 TEXTNOD =   sys.dbms_backup_restore.deviceStatus(state, devtype, name, bufsz, bufcnt,
DBGPLSQL:                        39 TEXTNOD =                                          kbytes, readrate, parallel);
DBGPLSQL:                        40 TEXTNOD =   begin
DBGPLSQL:                        41 TEXTNOD =      sys.dbms_backup_restore.bmrCancel;
DBGPLSQL:                        42 TEXTNOD =   exception
DBGPLSQL:                        43 TEXTNOD =      when others then
DBGPLSQL:                        44 TEXTNOD =         krmicd.clearErrors;
DBGPLSQL:                        45 TEXTNOD =   end;
DBGPLSQL:                        46 TEXTNOD =   begin
DBGPLSQL:                        47 TEXTNOD =      sys.dbms_backup_restore.flashbackCancel;
DBGPLSQL:                        48 TEXTNOD =   exception
DBGPLSQL:                        49 TEXTNOD =      when others then
DBGPLSQL:                        50 TEXTNOD =         krmicd.clearErrors;
DBGPLSQL:                        51 TEXTNOD =   end;
DBGPLSQL:                        52 TEXTNOD =   begin
DBGPLSQL:                        53 TEXTNOD =      sys.dbms_backup_restore.nbrCancel;
DBGPLSQL:                        54 TEXTNOD =   exception
DBGPLSQL:                        55 TEXTNOD =      when others then
DBGPLSQL:                        56 TEXTNOD =         krmicd.clearErrors;
DBGPLSQL:                        57 TEXTNOD =   end;
DBGPLSQL:                        58 TEXTNOD =   begin
DBGPLSQL:                        59 TEXTNOD =      sys.dbms_backup_restore.prePluginRecoveryCancel;
DBGPLSQL:                        60 TEXTNOD =   exception
DBGPLSQL:                        61 TEXTNOD =      when others then
DBGPLSQL:                        62 TEXTNOD =         krmicd.clearErrors;
DBGPLSQL:                        63 TEXTNOD =   end;
DBGPLSQL:                        64 TEXTNOD =   begin
DBGPLSQL:                        65 TEXTNOD =      sys.dbms_backup_restore.endPrePluginTranslation;
DBGPLSQL:                        66 TEXTNOD =   exception
DBGPLSQL:                        67 TEXTNOD =      when others then
DBGPLSQL:                        68 TEXTNOD =         krmicd.clearErrors;
DBGPLSQL:                        69 TEXTNOD =   end;
DBGPLSQL:                        70 TEXTNOD =   begin
DBGPLSQL:                        71 TEXTNOD =      sys.dbms_backup_restore.recoverCancel;
DBGPLSQL:                        72 TEXTNOD =   exception
DBGPLSQL:                        73 TEXTNOD =      when others then
DBGPLSQL:                        74 TEXTNOD =         krmicd.clearErrors;
DBGPLSQL:                        75 TEXTNOD =   end;
DBGPLSQL:                        76 TEXTNOD =   begin
DBGPLSQL:                        77 TEXTNOD =     if krmicd.mrCheck > 0 then
DBGPLSQL:                        78 TEXTNOD =       krmicd.execSql('alter database recover cancel');
DBGPLSQL:                        79 TEXTNOD =     end if;
DBGPLSQL:                        80 TEXTNOD =   exception
DBGPLSQL:                        81 TEXTNOD =     when others then
DBGPLSQL:                        82 TEXTNOD =       krmicd.clearErrors;
DBGPLSQL:                        83 TEXTNOD =   end;
DBGPLSQL:                        84 TEXTNOD =   begin
DBGPLSQL:                        85 TEXTNOD =      sys.dbms_backup_restore.cleanupPgaContext;
DBGPLSQL:                        86 TEXTNOD =   exception
DBGPLSQL:                        87 TEXTNOD =      when others then
DBGPLSQL:                        88 TEXTNOD =         krmicd.clearErrors;
DBGPLSQL:                        89 TEXTNOD =   end;
DBGPLSQL:                        90 TEXTNOD =  
DBGPLSQL:                        91 TEXTNOD = --
DBGPLSQL:                        92 TEXTNOD = --
DBGPLSQL:                        93 TEXTNOD = --
DBGPLSQL:                        94 TEXTNOD = --
DBGPLSQL:                        95 TEXTNOD = --
DBGPLSQL:                        96 TEXTNOD = --
DBGPLSQL:                        97 TEXTNOD =   if (autochn = 0) then
DBGPLSQL:                        98 TEXTNOD =     if (state > sys.dbms_backup_restore.NO_DEVICE) then
DBGPLSQL:                        99 TEXTNOD =        sys.dbms_backup_restore.deviceDeallocate;        
DBGPLSQL:                       100 TEXTNOD =        krmicd.writeMsg(8031, krmicd.getChid);
DBGPLSQL:                       101 TEXTNOD = --
DBGPLSQL:                       102 TEXTNOD = --
DBGPLSQL:                       103 TEXTNOD = --
DBGPLSQL:                       104 TEXTNOD =        sys.dbms_backup_restore.set_client_info('');
DBGPLSQL:                       105 TEXTNOD =     end if;
DBGPLSQL:                       106 TEXTNOD =     krmicd.clearChannelInfo;                    -- tell krmq no device here now
DBGPLSQL:                       107 TEXTNOD =   end if;
DBGPLSQL:                       108 TEXTNOD =   sys.dbms_backup_restore.setRmanStatusRowId(rsid=>0, rsts=>0);
DBGPLSQL:                       109 TEXTNOD = end;
DBGMISC:               EXITED krmicomp with address 40425112 [23:19:02.537] elapsed time [00:00:00:00.088]
DBGMISC:               ENTERED krmiexe [23:19:02.537]
DBGMISC:                Executing command cleanup [23:19:02.537] (krmiexe)
DBGRPC:                 krmxr - entering
DBGRPC:                 krmxpoq - returning rpc_number: 14 with status: FINISHED134 for channel default
DBGRPC:                 krmxr - channel default has rpc_count: 14
DBGRPC:                 krmxpoq - returning rpc_number: 5 with status: FINISHED3 for channel ORA_DISK_1
DBGRPC:                 krmxr - channel ORA_DISK_1 has rpc_count: 5
DBGRPC:                 ENTERED krmqgns
DBGRPC:                  krmqgns: looking for work for channel default (krmqgns)
DBGRPC:                  krmqgns: commands remaining to be executed: (krmqgns)
DBGRPC:                  CMD type=cleanup cmdid=1 status=NOT STARTED
DBGRPC:                        1 STEPstepid=1 cmdid=1 status=NOT STARTED
DBGRPC:                  krmqgns: channel default running cleanup (krmqgns)
DBGRPC:                 EXITED krmqgns with status 0
DBGRPC:                 ENTERED krmqgns
DBGRPC:                  krmqgns: looking for work for channel ORA_DISK_1 (krmqgns)
DBGRPC:                  krmqgns: commands remaining to be executed: (krmqgns)
DBGRPC:                  CMD type=cleanup cmdid=1 status=NOT STARTED
DBGRPC:                        1 STEPstepid=1 cmdid=1 status=NOT STARTED
DBGRPC:                  krmqgns: channel ORA_DISK_1 running cleanup (krmqgns)
DBGRPC:                 EXITED krmqgns with status 0
DBGRPC:                 krmxcis - channel default, calling pcicmp
DBGRPC:                 krmxcis - channel ORA_DISK_1, calling pcicmp
DBGRPC:                 krmxr - channel default calling peicnt
DBGRPC:                 krmxrpc - channel default kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.BACKUPCANCEL excl: 0
DBGRPC:                 krmxrpc - channel default kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.RESTORECANCEL excl: 0
DBGRPC:                 krmxrpc - channel default kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.PROXYCANCEL excl: 0
DBGRPC:                 krmxrpc - channel default kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.CFILEUSECURRENT excl: 0
DBGRPC:                 krmxrpc - channel default kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.DEVICESTATUS excl: 0
DBGRPC:                 krmxrpc - channel default kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.BMRCANCEL excl: 0
DBGRPC:                 krmxrpc - channel default kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.FLASHBACKCANCEL excl: 0
DBGRPC:                 krmxrpc - channel default kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.NBRCANCEL excl: 0
DBGRPC:                 krmxrpc - channel default kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.PREPLUGINRECOVERYCANCEL excl: 0
DBGRPC:                 krmxrpc - channel default kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.ENDPREPLUGINTRANSLATION excl: 0
DBGRPC:                 krmxrpc - channel default kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.RECOVERCANCEL excl: 0
DBGRPC:                 krmxrpc - channel default kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.CLEANUPPGACONTEXT excl: 0
DBGRPC:                 krmxrpc - channel default kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.SETRMANSTATUSROWID excl: 0
DBGRPC:                 krmxr - channel default returned from peicnt
DBGRPC:                 krmxr - channel default finished step
DBGRPC:                              ENTERED krmqgns
krmqgns: looking for work for channel default (krmqgns)
DBGRPC:                  krmqgns: commands remaining to be executed: (krmqgns)
DBGRPC:                  CMD type=cleanup cmdid=1 status=NOT STARTED
DBGRPC:                        1 STEPstepid=1 cmdid=1 status=NOT STARTED
DBGRPC:                  krmqgns: no work found for channel default (krmqgns)
DBGRPC:                   (krmqgns)
DBGRPC:                 EXITED krmqgns with status 1
DBGRPC:                 krmxr - channel ORA_DISK_1 calling peicnt
DBGRPC:                 krmxrpc - channel ORA_DISK_1 kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.BACKUPCANCEL excl: 0
DBGRPC:                 krmxrpc - channel ORA_DISK_1 kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.RESTORECANCEL excl: 0
DBGRPC:                 krmxrpc - channel ORA_DISK_1 kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.PROXYCANCEL excl: 0
DBGRPC:                 krmxrpc - channel ORA_DISK_1 kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.CFILEUSECURRENT excl: 0
DBGRPC:                 krmxrpc - channel ORA_DISK_1 kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.DEVICESTATUS excl: 0
DBGRPC:                 krmxrpc - channel ORA_DISK_1 kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.BMRCANCEL excl: 0
DBGRPC:                 krmxrpc - channel ORA_DISK_1 kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.FLASHBACKCANCEL excl: 0
DBGRPC:                 krmxrpc - channel ORA_DISK_1 kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.NBRCANCEL excl: 0
DBGRPC:                 krmxrpc - channel ORA_DISK_1 kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.PREPLUGINRECOVERYCANCEL excl: 0
DBGRPC:                 krmxrpc - channel ORA_DISK_1 kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.ENDPREPLUGINTRANSLATION excl: 0
DBGRPC:                 krmxrpc - channel ORA_DISK_1 kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.RECOVERCANCEL excl: 0
DBGRPC:                 krmxrpc - channel ORA_DISK_1 kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.CLEANUPPGACONTEXT excl: 0
DBGRPC:                 krmxrpc - channel ORA_DISK_1 kpurpc2 err=0 db=target proc=SYS.DBMS_BACKUP_RESTORE.SETRMANSTATUSROWID excl: 0
DBGRPC:                 krmxr - channel ORA_DISK_1 returned from peicnt
DBGRPC:                 krmxr - channel ORA_DISK_1 finished step
DBGRPC:                              ENTERED krmqgns
krmqgns: looking for work for channel default (krmqgns)
DBGRPC:                  krmqgns: commands remaining to be executed: (krmqgns)
DBGRPC:                  CMD type=cleanup cmdid=1 status=NOT STARTED
DBGRPC:                        1 STEPstepid=1 cmdid=1 status=NOT STARTED
DBGRPC:                  krmqgns: no work found for channel default (krmqgns)
DBGRPC:                   (krmqgns)
DBGRPC:                 EXITED krmqgns with status 1
DBGRPC:                 ENTERED krmqgns
DBGRPC:                  krmqgns: looking for work for channel ORA_DISK_1 (krmqgns)
DBGRPC:                  krmqgns: commands remaining to be executed: (krmqgns)
DBGRPC:                  CMD type=cleanup cmdid=1 status=NOT STARTED
DBGRPC:                        1 STEPstepid=1 cmdid=1 status=NOT STARTED
DBGRPC:                  krmqgns: no work found for channel ORA_DISK_1 (krmqgns)
DBGRPC:                   (krmqgns)
DBGRPC:                 EXITED krmqgns with status 1
DBGRPC:                 ENTERED krmqgns
DBGRPC:                  krmqgns: looking for work for channel default (krmqgns)
DBGRPC:                  krmqgns: commands remaining to be executed: (krmqgns)
DBGRPC:                  CMD type=cleanup cmdid=1 status=NOT STARTED
DBGRPC:                        1 STEPstepid=1 cmdid=1 status=NOT STARTED
DBGRPC:                  krmqgns: no work found for channel default (krmqgns)
DBGRPC:                   (krmqgns)
DBGRPC:                 EXITED krmqgns with status 1
DBGRPC:                 ENTERED krmqgns
DBGRPC:                  krmqgns: looking for work for channel ORA_DISK_1 (krmqgns)
DBGRPC:                  krmqgns: commands remaining to be executed: (krmqgns)
DBGRPC:                  CMD type=cleanup cmdid=1 status=NOT STARTED
DBGRPC:                        1 STEPstepid=1 cmdid=1 status=NOT STARTED
DBGRPC:                  krmqgns: no work found for channel ORA_DISK_1 (krmqgns)
DBGRPC:                   (krmqgns)
DBGRPC:                 EXITED krmqgns with status 1
DBGRPC:                 krmxr - all done
DBGRPC:                 krmxr - exiting with 0
DBGMISC:               EXITED krmiexe with status 0 [23:19:02.649] elapsed time [00:00:00:00.111]
DBGMISC:               Finished cleanup at 26-FEB-2020 23:19:02 [23:19:02.649]
DBGMISC:               ENTERED krmkjcl [23:19:02.649]
DBGMISC:               EXITED krmkjcl [23:19:02.649] elapsed time [00:00:00:00.000]
DBGMISC:              EXITED krmice [23:19:02.650] elapsed time [00:00:00:00.201]
Calling krmmpem from krmmexe
RMAN-00571: ===========================================================
RMAN-00569: =============== ERROR MESSAGE STACK FOLLOWS ===============
RMAN-00571: ===========================================================
RMAN-03002: failure of recover command at 02/26/2020 23:19:02
RMAN-05002: aborting Tablespace Point-in-Time Recovery
RMAN-05517: tempfile /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_temp_h5fz1y7v_.dbf conflicts with file used by target database
RMAN-05517: tempfile /u01/oradata/TRMAN01/temp01TRMAN01.dbf conflicts with file used by target database
RMAN-05001: auxiliary file name /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_sysaux_h5fz1y7m_.dbf conflicts with a file used by the target database
RMAN-05001: auxiliary file name /u01/oradata/TRMAN01/sysaux01TRMAN01.dbf conflicts with a file used by the target database
RMAN-05001: auxiliary file name /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_undotbs1_h5fz1y7p_.dbf conflicts with a file used by the target database
RMAN-05001: auxiliary file name /u01/oradata/TRMAN01/undotbs01TRMAN01.dbf conflicts with a file used by the target database
RMAN-05001: auxiliary file name /u01/oradata/TRMAN01/TSPITR/TRMAN01/9F83CA688D186D6FE053030011AC1BBD/datafile/o1_mf_system_h5fz1y7j_.dbf conflicts with a file used by the target database
RMAN-05001: auxiliary file name /u01/oradata/TRMAN01/system01TRMAN01.dbf conflicts with a file used by the target database
DBGMISC:              ENTERED krmkursr [23:19:02.658]

DBGSQL:                TARGET> select decode(status, 'OPEN', 1, 0), decode(archiver, 'FAILED', 1, 0), decode(database_status, 'SUSPENDED', 1, 0) into :status, :archstuck, :dbsuspended from v$instance
DBGSQL:                   sqlcode = 0
DBGSQL:                    D :status = 1
DBGSQL:                    D :archstuck = 0
DBGSQL:                    D :dbsuspended = 0

DBGSQL:                TARGET> select decode(open_mode, 'READ WRITE', 1, 0) into :read_write from v$database
DBGSQL:                   sqlcode = 0
DBGSQL:                    D :read_write = 1

DBGSQL:                TARGET> select value into :vcomp_txt from  v$parameter where name = 'compatible'
DBGSQL:                   sqlcode = 0
DBGSQL:                    D :vcomp_txt = 19.0.0

DBGSQL:                TARGET> declare dot1st number; dot2nd number; dot3rd number; comptxt varchar2(255) := :vcomp_txt; begin comptxt := comptxt || '.0.0'; dot1st := instr(comptxt, '.', 1, 1); dot2nd := instr(comptxt, '.', 1, 2); dot3rd := instr(comptxt, '.', 1, 3); comptxt :=  lpad(substr(comptxt, 1, dot1st - 1), 2, '0') || lpad(substr(comptxt, dot1st + 1, dot2nd - dot1st - 1), 2, '0')  || lpad(substr(comptxt, dot2nd + 1, dot3rd - dot2nd - 1), 2, '0');:vcomp_ub4 := to_number(comptxt); end;
DBGSQL:                   sqlcode = 0
DBGSQL:                    B :vcomp_ub4 = 190000
DBGSQL:                    B :vcomp_txt = 19.0.0
DBGMISC:               krmkpdbs(): vcomp_txt:19.0.0 vcomp_ub4:190000 flags:5 [23:19:02.682]

DBGSQL:                TARGET> begin sys.dbms_backup_restore.updateRmanStatusRow( row_id    => :row_id, row_stamp => :row_stamp, status    => :status); end;
DBGSQL:                   sqlcode = 0
DBGSQL:                    B :row_id = 538
DBGSQL:                    B :row_stamp = 1033427908
DBGSQL:                    B :status = 17
DBGMISC:              EXITED krmkursr [23:19:02.688] elapsed time [00:00:00:00.030]

RMAN> 

DBGMISC:              Node # 1 [23:19:02.720]
DBGMISC:              EXIT

Recovery Manager complete.
DBGRPC:     krmxt - terminating krmx layer
DBGRPC:     krmxt - destroying context for channel default
DBGRPC:     krmxcd - removing context for channel default, keep=0
DBGRPC:     krmxcd - closing target default connection
DBGMISC:    ENTERED krmkmrsr [23:19:02.729]
DBGMISC:      Skipping calculating MBYTES/INPUT/OUTPUT_BYTES for  rec id 538 [23:19:02.730] (krmkmrsr)

DBGSQL:      TARGET> begin sys.dbms_backup_restore.commitRmanStatusRow( row_id    => :row_id, row_stamp => :row_stamp, mbytes    => :mb, status    => :status, ibytes    => :ib, obytes    => :ob, odevtype  => :odevtype); end;
DBGSQL:         sqlcode = 0
DBGSQL:          B :row_id = 538
DBGSQL:          B :row_stamp = 1033427908
DBGSQL:          B :mb = 0
DBGSQL:          B :status = 18
DBGSQL:          B :ib = 0
DBGSQL:          B :ob = 0
DBGSQL:          B :odevtype = 
DBGMISC:    EXITED krmkmrsr [23:19:02.746] elapsed time [00:00:00:00.017]
DBGRPC:     krmxpoc - clearing channel default
DBGRPC:     krmxpoc - channel default, polling connection is still needed
DBGRPC:     krmxpoc - channel default, freeing polling context
DBGRPC:     krmxcd - disconnecting
DBGMISC:    ENTERED krmksimronly [23:19:02.748]
DBGMISC:    EXITED krmksimronly [23:19:02.748] elapsed time [00:00:00:00.000]
DBGRPC:     krmxcd - context removed
DBGRPC:     krmxt - destroying context for channel ORA_DISK_1
DBGRPC:     krmxcd - removing context for channel ORA_DISK_1, keep=0
DBGRPC:     krmxpoc - clearing channel ORA_DISK_1
DBGRPC:     krmxpocx - cleaning polling context for channel ORA_DISK_1
DBGRPC:     krmxpocx - cleaning target polling channel
DBGRPC:     krmxpocx - closing the cursor
DBGRPC:     krmxpocx - logging off from oracle
DBGRPC:     krmxpocx - freeing krmxpon
DBGRPC:     krmxpocx - target polling channel cleaned up
DBGRPC:     krmxpoc - channel ORA_DISK_1, freeing polling context
DBGRPC:     krmxcd - context removed
DBGRPC:     krmxt - krmxx context freed
